




<!DOCTYPE html>
<html lang="en">
<html>
    <head>
        <title>EmulatorJS</title>
        <link rel = icon href = docs/favicon.ico sizes = "16x16 32x32 48x48 64x64" type = image/vnd.microsoft.icon>
        <meta name = viewport content = "width = device-width, initial-scale = 1">
        <style>
             body, html {
                height: 100%;
                background-color: black;
                color: white;
            }

            body {
                margin: 0;
                overflow: hidden;
            }

            body, #box, #top {
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
            }

            #box {
                color: #aaa;
                height: 20em;
                width: 30em;
                max-width: 80%;
                max-height: 80%;
                background-color: #333;
                border-radius: 0.4em;
                border: 2px solid #555;
                position: relative;
                flex-direction: column;
                transition-duration: 0.2s;
                overflow: hidden;
                font-family: monospace;
                font-weight: bold;
                font-size: 20px;
                margin: 5px;
            }

            #box:hover, #box[drag] {
                border-color: #38f;
                color: #ddd
            }

            #input {
                cursor: pointer;
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                opacity: 0
            }

            #display {
                width: 100%;
                height: 100%
            }

            select, button {
                padding: 0.6em 0.4em;
                margin: 0.5em;
                width: 15em;
                max-width: 100%;
                font-family: monospace;
                font-weight: bold;
                font-size: 16px;
                background-color: #6A5F7D;
                color: #aaa;
                border-radius: 0.4em;
                border: 1px solid #555;
                cursor: pointer;
                transition-duration: 0.2s
            }

            select:hover, button:hover {
                background-color: #666;
                color: #ddd
            }

            .logo {
                width: 130px;
                height: 130px;
                filter: drop-shadow(0 0 10px white);
            }

            #top {
                margin: 5px;
            }
        </style>
    </head>

    <body>
        <div id="top">
            <h1>EmulatorJS Demo</h1>
            <img src="docs/Logo-light.png" alt="Logo" class="logo">
        </div>
    <script>
	// save your server ip and port serverip.txt in emulator folder
	

	    window.EJS_defaultOptions = {
'ff-ratio':'1.5',
'pcsx_rearmed_cd_readahead':'32',
'pcsx_rearmed_psxclock':'33',
'shader':'crt-aperture.glslp'
        };
      window.onload = async function () {
  // ——— Load server IP from serverip.txt, fallback to tailscaleserverip.txt if unreachable ———
  // serverip.txt and tailscaleserverip.txt should contain strings like: 192.168.0.237:8080 or 100.121.13.50:8080
  let serverIP = 'localhost:8080';

  // Tiny reachability probe using an Image (avoids CORS problems)
  function hostIsReachable(host, timeout = 1500) {
    return new Promise((resolve) => {
      let done = false;
      const img = new Image();
      const timer = setTimeout(() => {
        if (done) return;
        done = true;
        img.src = '';
        resolve(false);
      }, timeout);

      img.onload = () => {
        if (done) return;
        done = true;
        clearTimeout(timer);
        resolve(true);
      };
      img.onerror = () => {
        if (done) return;
        done = true;
        clearTimeout(timer);
        resolve(false);
      };

      // use favicon (small) — add timestamp to avoid caching
      img.src = `http://${host}/favicon.ico?ts=${Date.now()}`;
    });
  }

  async function chooseServerIP() {
    // helper: try reading a file and returning trimmed text or null
    async function readFileTrim(path) {
      try {
        const r = await fetch(path, { cache: 'no-store' });
        if (!r.ok) return null;
        const t = (await r.text()).trim();
        return t || null;
      } catch (e) {
        return null;
      }
    }

    // 1) try serverip.txt
    const ipFromFile = await readFileTrim('./serverip.txt');
    if (ipFromFile) {
      console.log('serverip.txt contains:', ipFromFile);
      if (await hostIsReachable(ipFromFile)) {
        console.log('Using serverip.txt value:', ipFromFile);
        return ipFromFile;
      } else {
        console.warn('serverip.txt value not reachable:', ipFromFile);
      }
    } else {
      console.warn('serverip.txt not found or empty, will try tailscaleserverip.txt');
    }

    // 2) try tailscaleserverip.txt
    const tailIp = await readFileTrim('./tailscaleserverip.txt');
    if (tailIp) {
      console.log('tailscaleserverip.txt contains:', tailIp);
      if (await hostIsReachable(tailIp)) {
        console.log('Using tailscaleserverip.txt value:', tailIp);
        return tailIp;
      } else {
        console.warn('tailscaleserverip.txt value not reachable:', tailIp);
      }
    } else {
      console.warn('tailscaleserverip.txt not found or empty');
    }

    // 3) fallback
    console.warn('Falling back to default:', serverIP);
    return serverIP;
  }

  try {
    serverIP = await chooseServerIP();
  } catch (e) {
    console.warn('Error choosing server IP — using default:', serverIP, e);
  }
// ——— End server IP selection ———
// ——— Begin original onload logic ———
  const urlParams = new URLSearchParams(window.location.search);
  const romParam  = urlParams.get('rom');

  if (!romParam) {
    console.error("No ROM specified in the URL.");
    return;
  }

  // Clear the page content
  document.body.innerHTML = "";

  // Create emulator container
  const displayDiv = document.createElement("div");
  displayDiv.id = "display";
  const gameDiv = document.createElement("div");
  gameDiv.id = "game";
  displayDiv.appendChild(gameDiv);
  document.body.appendChild(displayDiv);

  // Configure EmulatorJS
  window.EJS_player      = "#game";
  window.EJS_gameName    = romParam;
window.EJS_biosUrl = `http://${serverIP}/emulator/SCPH1001.BIN`;
  window.EJS_gameUrl     = `http://${serverIP}/emulator/roms/${romParam}?t=${Date.now()}`;
 window.EJS_core        = "gb";
  window.EJS_pathtodata  = "data/";
  window.EJS_startOnLoaded = true;
EJS_defaultControls = {
  0: { // player 0 (unique single chars)
    0:  { value: 'q', value2: 'BUTTON_1' },
    1:  { value: 'e', value2: 'BUTTON_3' },
    2:  { value: 'r', value2: 'SELECT' },
    3:  { value: 'tab', value2: 'START' },
    4:  { value: 'up arrow',    value2: 'DPAD_UP' },
    5:  { value: 'down arrow',  value2: 'DPAD_DOWN' },
    6:  { value: 'left arrow',  value2: 'DPAD_LEFT' },
    7:  { value: 'right arrow', value2: 'DPAD_RIGHT' },
    8:  { value: '1', value2: 'BUTTON_2' },
    9:  { value: '2', value2: 'BUTTON_4' },
    10: { value: '3', value2: 'LEFT_TOP_SHOULDER' },
    11: { value: '4', value2: 'RIGHT_TOP_SHOULDER' },
    12: { value: '5', value2: 'LEFT_BOTTOM_SHOULDER' },
    13: { value: '6', value2: 'RIGHT_BOTTOM_SHOULDER' },
    14: { value: '', value2: 'LEFT_STICK' },
    15: { value: '', value2: 'RIGHT_STICK' },
    16: { value: '7', value2: 'LEFT_STICK_X:+1' },
    17: { value: '8', value2: 'LEFT_STICK_X:-1' },
    18: { value: 't', value2: 'LEFT_STICK_Y:+1' },
    19: { value: 'g', value2: 'LEFT_STICK_Y:-1' },
    20: { value: 'h', value2: 'RIGHT_STICK_X:+1' },
    21: { value: 'f', value2: 'RIGHT_STICK_X:-1' },
    22: { value: 'z', value2: 'RIGHT_STICK_Y:+1' },
    23: { value: 'x', value2: 'RIGHT_STICK_Y:-1' },
    24: { value: '' },
    25: { value: '' },
    26: { value: '' },
    27: { value: '' },
    28: { value: '' },
    29: { value: '' }
  },

  1: { // player 1 (unique single chars, no repeats vs player 0)
    0:  { value: 'c', value2: 'BUTTON_1' },
    1:  { value: 'v', value2: 'BUTTON_3' },
    2:  { value: 'b', value2: 'SELECT' },
    3:  { value: 'n', value2: 'START' },
    4:  { value: 'w', value2: 'DPAD_UP' },
    5:  { value: 'a', value2: 'DPAD_DOWN' },
    6:  { value: 's', value2: 'DPAD_LEFT' },
    7:  { value: 'd', value2: 'DPAD_RIGHT' },
    8:  { value: '8', value2: 'BUTTON_2' },
    9:  { value: '9', value2: 'BUTTON_4' },
    10: { value: 'a', value2: 'LEFT_TOP_SHOULDER' },
    11: { value: 'b', value2: 'RIGHT_TOP_SHOULDER' },
    12: { value: 'c', value2: 'LEFT_BOTTOM_SHOULDER' },
    13: { value: 'd', value2: 'RIGHT_BOTTOM_SHOULDER' },
    14: { value: '', value2: 'LEFT_STICK' },
    15: { value: '', value2: 'RIGHT_STICK' },
    16: { value: 'l', value2: 'LEFT_STICK_X:+1' },
    17: { value: 'j', value2: 'LEFT_STICK_X:-1' },
    18: { value: 'i', value2: 'LEFT_STICK_Y:+1' },
    19: { value: 'k', value2: 'LEFT_STICK_Y:-1' },
    20: { value: 'p', value2: 'RIGHT_STICK_X:+1' },
    21: { value: ']', value2: 'RIGHT_STICK_X:-1' },
    22: { value: '[', value2: 'RIGHT_STICK_Y:+1' },
    23: { value: '.', value2: 'RIGHT_STICK_Y:-1' },
    24: { value: '' },
    25: { value: '' },
    26: { value: '' },
    27: { value: '' },
    28: { value: '' },
    29: { value: '' }
  },

  2: { // player 2 (unique single chars, no repeats vs players 0/1)
    0:  { value: '!', value2: 'BUTTON_1' },
    1:  { value: '"', value2: 'BUTTON_3' },
    2:  { value: '#', value2: 'SELECT' },
    3:  { value: '$', value2: 'START' },
    4:  { value: '%', value2: 'DPAD_UP' },
    5:  { value: '&', value2: 'DPAD_DOWN' },
    6:  { value: "'", value2: 'DPAD_LEFT' },
    7:  { value: '(', value2: 'DPAD_RIGHT' },
    8:  { value: ')', value2: 'BUTTON_2' },
    9:  { value: '*', value2: 'BUTTON_4' },
    10: { value: '+', value2: 'LEFT_TOP_SHOULDER' },
    11: { value: ',', value2: 'RIGHT_TOP_SHOULDER' },
    12: { value: '-', value2: 'LEFT_BOTTOM_SHOULDER' },
    13: { value: '.', value2: 'RIGHT_BOTTOM_SHOULDER' },
    14: { value: '', value2: 'LEFT_STICK' },
    15: { value: '', value2: 'RIGHT_STICK' },
    16: { value: '/', value2: 'LEFT_STICK_X:+1' },
    17: { value: ';', value2: 'LEFT_STICK_X:-1' },
    18: { value: ':', value2: 'LEFT_STICK_Y:+1' },
    19: { value: '<', value2: 'LEFT_STICK_Y:-1' },
    20: { value: '=', value2: 'RIGHT_STICK_X:+1' },
    21: { value: '>', value2: 'RIGHT_STICK_X:-1' },
    22: { value: '?', value2: 'RIGHT_STICK_Y:+1' },
    23: { value: '@', value2: 'RIGHT_STICK_Y:-1' },
    24: { value: '[' },
    25: { value: ']' },
    26: { value: '{' },
    27: { value: '}' },
    28: { value: '|' },
    29: { value: '~' }
  },

  3: { // player 3 (unique single chars, no repeats vs players 0/1/2)
    0:  { value: '^', value2: 'BUTTON_1' },
    1:  { value: '`', value2: 'BUTTON_3' },
    2:  { value: 'α', value2: 'SELECT' },
    3:  { value: 'β', value2: 'START' },
    4:  { value: 'γ', value2: 'DPAD_UP' },
    5:  { value: 'δ', value2: 'DPAD_DOWN' },
    6:  { value: 'ε', value2: 'DPAD_LEFT' },
    7:  { value: 'ζ', value2: 'DPAD_RIGHT' },
    8:  { value: 'η', value2: 'BUTTON_2' },
    9:  { value: 'θ', value2: 'BUTTON_4' },
    10: { value: 'ι', value2: 'LEFT_TOP_SHOULDER' },
    11: { value: 'κ', value2: 'RIGHT_TOP_SHOULDER' },
    12: { value: 'λ', value2: 'LEFT_BOTTOM_SHOULDER' },
    13: { value: 'μ', value2: 'RIGHT_BOTTOM_SHOULDER' },
    14: { value: '', value2: 'LEFT_STICK' },
    15: { value: '', value2: 'RIGHT_STICK' },
    16: { value: 'ν', value2: 'LEFT_STICK_X:+1' },
    17: { value: 'ξ', value2: 'LEFT_STICK_X:-1' },
    18: { value: 'ο', value2: 'LEFT_STICK_Y:+1' },
    19: { value: 'π', value2: 'LEFT_STICK_Y:-1' },
    20: { value: 'ρ', value2: 'RIGHT_STICK_X:+1' },
    21: { value: 'σ', value2: 'RIGHT_STICK_X:-1' },
    22: { value: 'τ', value2: 'RIGHT_STICK_Y:+1' },
    23: { value: 'υ', value2: 'RIGHT_STICK_Y:-1' },
    24: { value: 'φ' },
    25: { value: 'χ' },
    26: { value: 'ψ' },
    27: { value: 'ω' },
    28: { value: '‚' },
    29: { value: 'ƒ' }
  }
};

	
		
            // Load EmulatorJS
            const script = document.createElement("script");
            script.src = "data/loader.js";
 script.onload = () => {
                console.log("EmulatorJS Loaded");
                
                // Create Save Location Dialog
                const saveDialog = document.createElement("div");
                saveDialog.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #333;
                    padding: 20px;
                    border-radius: 8px;
                    border: 2px solid #555;
                    z-index: 10000;
                    display: none;
                    box-shadow: 0 0 15px rgba(0,0,0,0.5);
                `;
                
const saveDialogContent = `
    <div style="text-align: center; color: #aaa; margin-bottom: 15px; font-family: monospace;">
        Choose Save Location
    </div>
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 0 10px;">
        <button id="saveBrowser" style="
            background: #5F7D6A;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
        ">Browser Storage</button>
        
        <button id="saveDownload" style="
            background: #6A5F7D;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
        ">Download File</button>
        
        <button id="saveMem1" style="
            background: #4E89AE;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
        ">Memory Card 1</button>
        
        <button id="saveMem2" style="
            background: #4E89AE;
            color: white;
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
        ">Memory Card 2</button>
    </div>
`;

                saveDialog.innerHTML = saveDialogContent;
                document.body.appendChild(saveDialog);


// Memory Card 1 ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¾ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ upload the raw state to /Profiles/<profile>-<game>.state
// ====== SAVE HANDLER (Memory Card 1) ======
document.getElementById('saveMem1').onclick = async () => {
  saveDialog.style.display = 'none';
  try {
    const emulator = window.EJS_emulator;
    const state    = emulator.gameManager.getState(); // Uint8Array
    const profile  = localStorage.getItem("activeProfile") || "Guest";
    const baseName = emulator.getBaseFileName();
    const fileName = `${profile}-${baseName}`;

    // Convert Uint8Array â†’ Base64
    function uint8ToBase64(uint8Array) {
      let binary = '';
      const chunkSize = 0x8000;
      for (let i = 0; i < uint8Array.length; i += chunkSize) {
        binary += String.fromCharCode.apply(null, uint8Array.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }
    const base64  = uint8ToBase64(state);
    const wrapped = `[[[${base64}]]]`;

    // Send as FormData blob
    const form = new FormData();
    form.append("files[]", new Blob([wrapped], { type: "text/plain" }), fileName);
    const res = await fetch(`/emulator/Mem1/${encodeURIComponent(fileName)}`, {
      method: 'PUT',
      body: form
    });
    if (!res.ok) throw new Error(`Server responded with ${res.status}`);
    showSavedIndicator();
  } catch (err) {
    console.error("Save failed:", err);
    alert(`Save error: ${err.message}`);
  }
};
// ====== SAVE HANDLER ======
// ====== SAVE HANDLER (Memory Card 2) ======
document.getElementById('saveMem2').onclick = async () => {
  saveDialog.style.display = 'none';
  try {
    const emulator = window.EJS_emulator;
    const state    = emulator.gameManager.getState(); // Uint8Array
    const profile  = localStorage.getItem("activeProfile") || "Guest";
    const baseName = emulator.getBaseFileName();
    const fileName = `${profile}-${baseName}`;

    // Convert Uint8Array â†’ Base64
    function uint8ToBase64(uint8Array) {
      let binary = '';
      const chunkSize = 0x8000;
      for (let i = 0; i < uint8Array.length; i += chunkSize) {
        binary += String.fromCharCode.apply(null, uint8Array.subarray(i, i + chunkSize));
      }
      return btoa(binary);
    }
    const base64  = uint8ToBase64(state);
    const wrapped = `[[[${base64}]]]`;

    // Send as FormData blob
    const form = new FormData();
    form.append("files[]", new Blob([wrapped], { type: "text/plain" }), fileName);
    const res = await fetch(`/emulator/Mem2/${encodeURIComponent(fileName)}`, {
      method: 'PUT',
      body: form
    });
    if (!res.ok) throw new Error(`Server responded with ${res.status}`);
    showSavedIndicator();
  } catch (err) {
    console.error("Save failed:", err);
    alert(`Save error: ${err.message}`);
  }
};


             // Home Button
                const homeButton = document.createElement("a");
                homeButton.href = "../index.html";
                homeButton.innerText = "Home";
                homeButton.style.cssText = `
                    position: fixed;
                    top: 5px;
                    left: 5px;
                    z-index: 9999;
                    padding: 3px 3px;
                    background: #ff4444;
                    color: white;
                    border-radius: 3px;
                    text-decoration: none;
                    font-family: Arial, sans-serif;
                    font-weight: bold;
                    box-shadow: 0 2px 2px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(homeButton);
                // Save Button
                const saveButton = document.createElement("a");
                saveButton.href = "#";
                saveButton.innerText = "Save";
                saveButton.style.cssText = `
                    position: fixed;
                    top: 5px;
                    left: 56px;
                    z-index: 9999;
                    padding: 3px 3px;
                    background: #6A5F7D;
                    color: white;
                    border-radius: 3px;
                    text-decoration: none;
                    font-family: Arial, sans-serif;
                    font-weight: bold;
                    box-shadow: 0 2px 2px rgba(0,0,0,0.3);
                `;
                saveButton.addEventListener('click', async (e) => {
                    e.preventDefault();
                    try {
                        const emulator = window.EJS_emulator;
                        const state = emulator.gameManager.getState();
                        const screenshot = await emulator.gameManager.screenshot();
                        
       // Close button for save dialog
const closeSaveDialogButton = document.createElement("button");
closeSaveDialogButton.innerHTML = "&times;";
closeSaveDialogButton.style.cssText = `
    position: absolute;
    top: 10px;
    right: 10px;
    background: transparent;
    border: none;
    color: white;
    font-size: 20px;
    cursor: pointer;
    padding: 0;
    line-height: 1;
`;
saveDialog.appendChild(closeSaveDialogButton);

closeSaveDialogButton.onclick = () => {
    saveDialog.style.display = 'none';
};

// Show save location dialog
saveDialog.style.display = 'block';
                        
                        // Browser storage handler
                        document.getElementById('saveBrowser').onclick = async () => {
    saveDialog.style.display = 'none';
    try {
        // Saving the game state to local storage
        const stateKey = emulator.getBaseFileName() + ".state";
        await emulator.storage.states.put(stateKey, state);
        console.log("State saved to browser storage with key:", stateKey);
  //      alert("State saved to browser storage!");
    } catch (error) {
        console.error("Browser save failed:", error);
        alert("Error saving to browser storage!");
    }
};
                        
                        // File download handler
                        document.getElementById('saveDownload').onclick = () => {
                            saveDialog.style.display = 'none';
                            try {
                                const blob = new Blob([state]);
                                const url = URL.createObjectURL(blob);
                                const link = document.createElement("a");
                                link.href = url;
                                link.download = emulator.getBaseFileName() + ".state";
                                link.click();
                                URL.revokeObjectURL(url);
                         //       alert("Save file downloading...");
                            } catch (error) {
                                console.error("Download failed:", error);
                                alert("Error generating download!");
                            }
                        };
                        
                    } catch (error) {
                        console.error("Save preparation failed:", error);
                        alert("Error preparing save!");
                    }
                });
                document.body.appendChild(saveButton);

// ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ Load Location Dialog ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬
const loadDialog = document.createElement("div");
Object.assign(loadDialog.style, {
  position: "fixed",
  top: "50%",
  left: "50%",
  transform: "translate(-50%, -50%)",
  background: "#333",
  padding: "20px",
  borderRadius: "8px",
  border: "2px solid #555",
  zIndex: "10000",
  display: "none",
  boxShadow: "0 0 15px rgba(0,0,0,0.5)",
});
loadDialog.innerHTML = `
  <div style="text-align:center;color:#aaa;margin-bottom:15px;font-family:monospace;">
    Choose Load Source
  </div>
  <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:10px;">
    <button id="loadBrowser" style="
      background:#5F7D6A;color:white;border:none;
      padding:8px;border-radius:4px;font-family:monospace;cursor:pointer;
    ">Browser Storage</button>
    <button id="loadFile" style="
      background:#6A5F7D;color:white;border:none;
      padding:8px;border-radius:4px;font-family:monospace;cursor:pointer;
    ">From File</button>
    <button id="loadMem1" style="
      background:#4E89AE;color:white;border:none;
      padding:8px;border-radius:4px;font-family:monospace;cursor:pointer;
    ">Memory Card 1</button>
    <button id="loadMem2" style="
      background:#4E89AE;color:white;border:none;
      padding:8px;border-radius:4px;font-family:monospace;cursor:pointer;
    ">Memory Card 2</button>
  </div>
`;
document.body.appendChild(loadDialog);

// === PLATFORM SWITCHABLE SAVE/LOAD HANDLERS ===
// ——— PLATFORM‑DRIVEN SAVE/LOAD HANDLERS ———
(async () => {
  // 1) Load platform string from file
  let platformMode = 'windows';  // fallback
  try {
    const txt = await fetch('./platform.txt', { cache: 'no-store' })
                     .then(res => {
                       if (!res.ok) throw new Error(res.status);
                       return res.text();
                     });
    platformMode = txt.trim();
  } catch (e) {
    console.warn('Could not load platform.txt, defaulting to “windows”');
  }

  // 2) Attach SAVE handlers
  ['saveMem1', 'saveMem2'].forEach((btnId, idx) => {
    const btn = document.getElementById(btnId);
    if (!btn) return;
    btn.onclick = async () => {
      saveDialog.style.display = 'none';
      try {
        const emulator = window.EJS_emulator;
        const state    = emulator.gameManager.getState();
        const profile  = localStorage.getItem("activeProfile") || "Guest";
        const baseName = emulator.getBaseFileName();
        const fileName = `${profile}-${baseName}`;
        const slot     = `Mem${idx+1}`;

        // Base64 helper
        function uint8ToBase64(u8) {
          let b='', cs=0x8000;
          for (let i=0; i<u8.length; i+=cs) b += String.fromCharCode.apply(null, u8.subarray(i, i+cs));
          return btoa(b);
        }

        const wrapped = `[[[${uint8ToBase64(state)}]]]`;
        const form    = new FormData();
        form.append("files[]", new Blob([wrapped], { type: "text/plain" }), fileName);

        // if you host this on Android http simple server plus, platform.txt should read: android
		// by default it is compatabile with window's simple web server 
        const url = platformMode === 'windows'
          ? `/emulator/${slot}/${encodeURIComponent(fileName)}`
          : `/api/file/upload?path=${encodeURIComponent(`/emulator/${slot}/`)}`;

        const res = await fetch(url, { method: 'PUT', body: form });
        if (!res.ok) throw new Error(res.status);
        showSavedIndicator();
      } catch (err) {
        console.error("Save failed:", err);
        alert(`Save error: ${err.message}`);
      }
    };
  });

  // 3) Attach LOAD handlers
  ['loadMem1','loadMem2'].forEach((btnId, idx) => {
    const btn = document.getElementById(btnId);
    if (!btn) return;
    btn.onclick = async () => {
      loadDialog.style.display = 'none';
      try {
        const emulator = window.EJS_emulator;
        const profile  = localStorage.getItem("activeProfile") || "Guest";
        const baseName = emulator.getBaseFileName();
        const fileName = `${profile}-${baseName}`;
        const slot     = `Mem${idx+1}`;
        let buffer     = null;

        for (const name of [fileName, fileName.replace(/\.[^.]+$/,'')]) {
          const res  = await fetch(`/emulator/${slot}/${encodeURIComponent(name)}`, { cache: 'no-store' });
          if (!res.ok) continue;
          const txt  = await res.text();
          const m    = txt.match(/\[\[\[([\s\S]*?)\]\]\]/);
          if (!m) continue;
          const bin  = atob(m[1]);
          buffer     = new Uint8Array([...bin].map(c=>c.charCodeAt(0)));
          break;
        }
        if (!buffer) throw new Error("No valid save found");
        await emulator.gameManager.loadState(buffer);
      } catch (err) {
        console.error("Load error:", err);
        alert(`Load error: ${err.message}`);
      }
    };
  });
})();

// Add Close Button to Load Dialog
const closeLoadDialogButton = document.createElement("button");
closeLoadDialogButton.innerHTML = "&times;";
Object.assign(closeLoadDialogButton.style, {
    position: "absolute",
    top: "-3px",
    right: "10px",
    background: "transparent",
    border: "none",
    color: "white",
    fontSize: "20px",
    cursor: "pointer",
    lineHeight: "1"
});
closeLoadDialogButton.onclick = () => {
    loadDialog.style.display = 'none';
};
loadDialog.appendChild(closeLoadDialogButton);

// 0000000000000000000000000000000000000000000000000
// ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ Load Button ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬
const loadButton = document.createElement("a");
loadButton.href = "#";
loadButton.innerText = "Load";
Object.assign(loadButton.style, {
  position: "fixed",
  top: "5px",
  left: "99px",
  zIndex: "9999",
  padding: "3px 3px",
  background: "#5F7D6A",
  color: "white",
  borderRadius: "3px",
  textDecoration: "none",
  fontFamily: "Arial, sans-serif",
  fontWeight: "bold",
  boxShadow: "0 2px 2px rgba(0,0,0,0.3)",
});
loadButton.addEventListener("click", (e) => {
  e.preventDefault();
  loadDialog.style.display = "block";
});
document.body.appendChild(loadButton);

// ====== LOAD HANDLER: Browser Storage ======
document.getElementById("loadBrowser").onclick = async () => {
  loadDialog.style.display = "none";
  try {
    const emulator = window.EJS_emulator;
    if (!emulator) throw new Error("Emulator not initialized");

    const stateKey = emulator.getBaseFileName() + ".state";
    const state = await emulator.storage.states.get(stateKey);
    if (state) {
      await emulator.gameManager.loadState(state);
      console.log("Loaded from Browser Storage:", stateKey);
    } else {
      alert("No saved state found in browser storage.");
    }
  } catch (err) {
    console.error("Load error:", err);
    alert(`Load error: ${err.message}`);
  }
};

// ====== LOAD HANDLER: From File ======
document.getElementById("loadFile").onclick = () => {
  loadDialog.style.display = "none";
  const input = document.createElement("input");
  input.type = "file";
  input.accept = ".state";
  input.onchange = async (e) => {
    const file = e.target.files[0];
    if (file) {
      try {
        const buffer = await file.arrayBuffer();
        await window.EJS_emulator.gameManager.loadState(new Uint8Array(buffer));
        console.log("Loaded state from file.");
      } catch (error) {
        console.error("Load error:", error);
        alert("Error loading file.");
      }
    }
  };
  input.click();
};

// ====== LOAD HANDLER: Memory Card 1 ======
// ====== LOAD HANDLER (Memory Card 1) ======
document.getElementById("loadMem1").onclick = async () => {
  loadDialog.style.display = 'none';
  try {
    const emulator = window.EJS_emulator;
    const profile  = localStorage.getItem("activeProfile") || "Guest";
    const baseName = emulator.getBaseFileName();
    const fileName = `${profile}-${baseName}`;

    // Fetch wrapped data
    const res = await fetch(`/emulator/Mem1/${encodeURIComponent(fileName)}`, { cache: 'no-store' });
    if (!res.ok) throw new Error(`Error fetching save (${res.status})`);
    const text = await res.text();

    // Extract Base64 from [[[â€¦]]]
    const match = text.match(/\[\[\[([\s\S]*?)\]\]\]/);
    if (!match) throw new Error("Save data malformed");

    // Decode Base64 â†’ Uint8Array
    const binary = atob(match[1]);
    const len    = binary.length;
    const buffer = new Uint8Array(len);
    for (let i = 0; i < len; i++) buffer[i] = binary.charCodeAt(i);

    await emulator.gameManager.loadState(buffer);
  } catch (err) {
    console.error("Load error:", err);
    alert(`Load error: ${err.message}`);
  }
};


// ====== LOAD HANDLER: Memory Card 2 ======
// ====== LOAD HANDLER (Memory Card 2) ======
document.getElementById("loadMem2").onclick = async () => {
  loadDialog.style.display = 'none';
  try {
    const emulator = window.EJS_emulator;
    const profile  = localStorage.getItem("activeProfile") || "Guest";
    const baseName = emulator.getBaseFileName();
    const fileName = `${profile}-${baseName}`;

    // Fetch wrapped data
    const res = await fetch(`/emulator/Mem2/${encodeURIComponent(fileName)}`, { cache: 'no-store' });
    if (!res.ok) throw new Error(`Error fetching save (${res.status})`);
    const text = await res.text();

    // Extract Base64 from [[[â€¦]]]
    const match = text.match(/\[\[\[([\s\S]*?)\]\]\]/);
    if (!match) throw new Error("Save data malformed");

    // Decode Base64 â†’ Uint8Array
    const binary = atob(match[1]);
    const len    = binary.length;
    const buffer = new Uint8Array(len);
    for (let i = 0; i < len; i++) buffer[i] = binary.charCodeAt(i);

    await emulator.gameManager.loadState(buffer);
  } catch (err) {
    console.error("Load error:", err);
    alert(`Load error: ${err.message}`);
  }
};


// ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ Active Profile Icon ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬
(function() {
const activeProfile = localStorage.getItem("activeProfile") || "Guest";
const img = document.createElement("img");
img.src = `./Profiles/${activeProfile}.jpg`;
img.alt = activeProfile;
img.width = 27; img.height = 26;
img.id = "activeProfileIcon";

// Add click listener to trigger save then redirect
img.addEventListener('click', async () => {
  try {
    const emulator = window.EJS_emulator;
    const state = emulator?.gameManager?.getState();

    if (state) {
      const stateKey = emulator.getBaseFileName() + ".state";
      await emulator.storage.states.put(stateKey, state);
      showSavedIndicator(); // optional visual feedback
    }
  } catch (err) {
    console.warn("Save to browser storage failed. Proceeding to profiles page...");
  } finally {
    // Always redirect regardless of save success
    window.location.href = "../Game-profiles.html";
  }
});

// Mirror the active profile icon into the netplay UI container (so it shows left of "Player X")
(function mirrorActiveProfileToNetplay(){
  const tryAppend = () => {
    const container = document.getElementById('netplayUIContainer');
    if (!container) return false;

    // avoid creating multiple clones
    if (document.getElementById('netplayProfileClone')) return true;

    // use a clone so original positioning/logic remains unchanged
    const clone = img.cloneNode(true);
    clone.id = 'netplayProfileClone';
    // remove any absolute/fixed layout attributes the original may have
    clone.style.position = '';
    clone.style.top = '';
    clone.style.left = '';
    clone.style.width = '27px';
    clone.style.height = '26px';
    clone.style.cursor = 'pointer';
    clone.style.pointerEvents = 'auto';

    // ensure clicking clone does same as original
    clone.addEventListener('click', (ev) => { ev.preventDefault(); img.click(); });

    // Insert clone before the Player label (so profile is left of "Player X")
    const label = document.getElementById('netplayPlayerLabel') || document.getElementById('playerLabel') || document.querySelector('.netplay-player-label');
    if (label) container.insertBefore(clone, label);
    else container.appendChild(clone);

    return true;
  };

  // Try immediate append; if container not present yet, observe DOM and try again
  if (!tryAppend()) {
    const mo = new MutationObserver(() => {
      if (tryAppend()) mo.disconnect();
    });
    mo.observe(document.body, { childList: true, subtree: true });

    // fallback attempt after a short delay (covers race conditions)
    setTimeout(() => { tryAppend() && mo.disconnect(); }, 1500);
  }
})();

// ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢
 // ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¦ ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬ ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬ ÃƒÆ’Ã†â€™Ãƒâ€ Ã¢â‚¬â„¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â Add this line
  Object.assign(img.style, {
    position: "fixed",
    borderRadius: "4px",
    boxShadow: "0 0 4px rgba(0,0,0,0.5)",
    zIndex: "10000"
  });
  requestAnimationFrame(() => {
    const rect = loadButton.getBoundingClientRect();
    img.style.top  = `${rect.top + (rect.height - img.height)/2}px`;
    img.style.left = `${rect.right + 1}px`;
  });
  document.body.appendChild(img);
})();

function showSavedIndicator() {
  const profileImg = document.getElementById("activeProfileIcon");
  if (!profileImg) return;

  // Remove old indicator if it's still there
  const existing = document.getElementById("savedIndicator");
  if (existing) existing.remove();

  const indicator = document.createElement("div");
  indicator.id = "savedIndicator";
  indicator.style.cssText = `
    position: fixed;
    width: 10px;
    height: 10px;
    background: #00cc66;
    border-radius: 50%;
    z-index: 10001;
  `;

  // Position it to the right of the profile icon
  const rect = profileImg.getBoundingClientRect();
  indicator.style.top = `${rect.top + 8}px`;
  indicator.style.left = `${rect.right + 5}px`;

  document.body.appendChild(indicator);

  // Remove after 2.5 seconds
  setTimeout(() => {
    indicator.remove();
  }, 2500);
}
// Fast Forward Button Implementation
const fastForwardButton = document.createElement("a");
fastForwardButton.href = "#";
fastForwardButton.innerHTML = "Fast";
Object.assign(fastForwardButton.style, {
    position: "fixed",
    top: "36px",
    right: "5px",
    zIndex: "9999",
    padding: "3px 8px",
    background: "#6A5F7D", // Initial color (off)
    color: "white",
    borderRadius: "3px",
    textDecoration: "none",
    fontFamily: "Arial, sans-serif",
    fontWeight: "bold",
    boxShadow: "0 2px 2px rgba(0,0,0,0.3)",
    cursor: "pointer"
});

let isFastForwardActive = false;

function toggleFastForward() {
    if (!window.EJS_emulator?.gameManager) return;
    
    // Toggle the state
    isFastForwardActive = !isFastForwardActive;
    
    // Update the emulator state
    window.EJS_emulator.gameManager.toggleFastForward(isFastForwardActive);
    
    // Update button appearance
    fastForwardButton.style.background = isFastForwardActive ? "#FFD700" : "#6A5F7D";
    console.log(`Fast Forward ${isFastForwardActive ? "ENABLED" : "DISABLED"}`);
}

fastForwardButton.addEventListener("click", (e) => {
    e.preventDefault();
    toggleFastForward();
});

document.body.appendChild(fastForwardButton);
// --- paste this near the top of the Netplay / WebRTC block (before any alert() calls) ---
function ejsNotify(msg) {
  try {
    // prefer the emulator displayMessage if available
    if (window.EJS_emulator && typeof window.EJS_emulator.displayMessage === 'function') {
      // keep it short & plain text
      window.EJS_emulator.displayMessage(String(msg));
      return;
    }
  } catch (e) {
    // ignore display errors
  }
  // fallback: console so nothing blocks fullscreen
  console.warn('ejsNotify:', msg);
}
// ------------------------------------------------------------------

<!-- START: Unified Netplay UI + WebRTC implementation (replace previous Netplay block entirely) -->

(() => {
  // Defensive removal of prior UI elements (prevents duplicates)
  const idsToRemove = [
    'netplayButton','netplayStatus','netplayDialog','guideButton','guideContainer','guideIframe',
    'fullscreenButton','fastForwardButton','netplayVideo','netplayOverlay','netplayUIContainer'
  ];
  idsToRemove.forEach(id => { const e = document.getElementById(id); if (e) e.remove(); });

  // Helper fallbacks for serverIP/romParam
  let SIGNAL_HOST = (typeof serverIP !== 'undefined' && serverIP) ? serverIP : 'localhost:8080';
  let romParamSafe = (typeof romParam !== 'undefined' && romParam) ? romParam : (new URLSearchParams(window.location.search).get('rom') || '');

  // Small DOM helpers
  function makeEl(tag, props = {}, style = {}) {
    const el = document.createElement(tag);
    Object.assign(el, props);
    Object.assign(el.style, style);
    return el;
  }

  // === Netplay UI ===
  const netplayButton = makeEl('a', { id: 'netplayButton', href: '#', innerText: 'Netplay' }, {
    position: 'fixed', top: '36px', left: '5px', zIndex: 9999, padding: '3px 8px',
    background: '#6A5F7D', color: 'white', borderRadius: '3px', textDecoration: 'none',
    fontFamily: 'Arial, sans-serif', fontWeight: 'bold', boxShadow: '0 2px 2px rgba(0,0,0,0.3)', cursor: 'pointer'
  });

  const netplayStatus = makeEl('div', { id: 'netplayStatus' }, {
    position: 'fixed', top: '36px', left: '90px', width: '16px', height: '16px', background: 'transparent',
    borderRadius: '3px', zIndex: 9999
  });

  const netplayDialog = makeEl('div', { id: 'netplayDialog' }, {
    position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%,-50%)',
    background: '#333', padding: '20px', borderRadius: '8px', border: '2px solid #555',
    zIndex: 10000, display: 'none', color: '#ddd', fontFamily: 'monospace', textAlign: 'center'
  });

  netplayDialog.innerHTML = `
    <div style="color:#aaa;margin-bottom:12px;font-family:monospace">Choose Netplay Mode</div>
    <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:10px;">
      <button id="hostBtn" style="background:#4E89AE;color:#fff;padding:8px;border-radius:4px;border:none;cursor:pointer;font-family:monospace">Host</button>
      <button id="joinBtn" style="background:#5F7D6A;color:#fff;padding:8px;border-radius:4px;border:none;cursor:pointer;font-family:monospace">Join</button>
      <button id="toggleLink" style="background:#6A5F7D;color:#fff;padding:8px;border-radius:4px;border:none;cursor:pointer;font-family:monospace">Link Trade Cable</button>
      <button id="toggleShared" style="background:#FFD700;color:#fff;padding:8px;border-radius:4px;border:none;cursor:pointer;font-family:monospace">Shared Console</button>
    </div>
    <div style="margin-top:12px"><button id="disconnectBtn" style="background:#ff4444;color:#fff;padding:8px 16px;border:none;border-radius:4px;cursor:pointer">Disconnect</button></div>
  `;

  const netplayClose = makeEl('button', { innerHTML: '&times;' }, {
    position: 'absolute', top: '-6px', right: '10px', background: 'transparent', border: 'none', color: 'white', fontSize: '20px', cursor: 'pointer'
  });
  netplayDialog.appendChild(netplayClose);

  // append to DOM
  document.body.appendChild(netplayButton);
  document.body.appendChild(netplayStatus);
  document.body.appendChild(netplayDialog);



  // === Fullscreen button ===
  if (!document.getElementById('fullscreenButton')) {
    const fs = makeEl('a', { id: 'fullscreenButton', innerText: 'Fullscreen', href: '#' }, {
      position: 'fixed', top: '5px', right: '5px', zIndex: 10001,
      padding: '3px 6px', background: '#6A5F7D', color: 'white', borderRadius: '3px',
      textDecoration: 'none', fontFamily: 'Arial, sans-serif', fontWeight: 'bold', cursor: 'pointer'
    });
    fs.addEventListener('click', (e) => {
      e.preventDefault();
      if (!document.fullscreenElement) document.documentElement.requestFullscreen().then(() => fs.innerText = 'Exit Fullscreen').catch(console.error);
      else document.exitFullscreen().then(() => fs.innerText = 'Fullscreen').catch(console.error);
    });
    document.body.appendChild(fs);
  }

  // === Fast Forward button ===
  if (!document.getElementById('fastForwardButton')) {
    const ff = makeEl('a', { id: 'fastForwardButton', innerText: 'Fast', href: '#' }, {
      position: 'fixed', top: '36px', right: '5px', zIndex: 10001,
      padding: '3px 8px', background: '#6A5F7D', color: 'white', borderRadius: '3px',
      textDecoration: 'none', fontFamily: 'Arial, sans-serif', fontWeight: 'bold', cursor: 'pointer'
    });
    let isFast = false;
    function toggleFast() {
      if (window.EJS_emulator?.gameManager?.toggleFastForward) {
        isFast = !isFast;
        try { window.EJS_emulator.gameManager.toggleFastForward(isFast); } catch (e) { console.warn(e); }
        ff.style.background = isFast ? '#FFD700' : '#6A5F7D';
      } else {
        ejsNotify('Fast-forward not supported by this emulator build.');
      }
    }
    ff.addEventListener('click', (e) => { e.preventDefault(); toggleFast(); });
    document.body.appendChild(ff);
  }

  // === Small visuals state ===
  let netplayMode = null, linkTradeEnabled = false, sharedConsoleEnabled = false;
  function updateNetplayVisuals() {
    if (netplayMode === 'hosting') { netplayButton.innerText = 'Hosting'; netplayButton.style.background = '#4E89AE'; }
    else if (netplayMode === 'joining') { netplayButton.innerText = 'Joining'; netplayButton.style.background = '#5F7D6A'; }
    else { netplayButton.innerText = 'Netplay'; netplayButton.style.background = '#6A5F7D'; }

    if (netplayMode) {
      const primary = netplayMode === 'hosting' ? 'blue' : 'green';
      if (linkTradeEnabled) netplayStatus.style.background = `linear-gradient(to right, ${primary} 50%, purple 50%)`;
      else if (sharedConsoleEnabled) netplayStatus.style.background = `linear-gradient(to right, ${primary} 50%, yellow 50%)`;
      else netplayStatus.style.background = primary;
    } else netplayStatus.style.background = 'transparent';
  }

  // Wire up simple dialog controls
  netplayButton.addEventListener('click', (e) => { e.preventDefault(); netplayDialog.style.display = 'block'; });
  netplayClose.addEventListener('click', () => { netplayDialog.style.display = 'none'; });
  netplayDialog.querySelector('#hostBtn').onclick = () => { netplayMode = 'hosting'; updateNetplayVisuals(); };
  netplayDialog.querySelector('#joinBtn').onclick = () => { netplayMode = 'joining'; updateNetplayVisuals(); };
  netplayDialog.querySelector('#toggleLink').onclick = () => { linkTradeEnabled = !linkTradeEnabled; sharedConsoleEnabled = false; updateNetplayVisuals(); };

  // utility: try to find the DOM element by many common selectors
  function findElementBySelectors(list) {
    for (const sel of list) {
      const el = document.querySelector(sel);
      if (el) return el;
    }
    return null;
  }

  // clone top-left UI (Home + Active Profile) into overlay container while removing Save/Load inside the clone
  function installTopLeftUIClone() {
    if (document.getElementById('netplayUIContainer')) return; // already installed
    const container = makeEl('div', { id: 'netplayUIContainer' }, {
      position: 'fixed', top: '8px', left: '8px', zIndex: 100001, display: 'flex', gap: '8px', alignItems: 'center', pointerEvents: 'auto'
    });

    // possible home selectors (common names)
    const homeSel = ['#homeButton', '#home', '#homeBtn', '.home-button', '#nav-home', 'a.home', 'button.home', '[data-role="home"]'];
    const profileSel = ['#activeProfileIcon', '#profileIcon', '#profileButton', '.profile-icon', '#activeProfile', '#profile', '.profile'];

    const home = findElementBySelectors(homeSel);
    const profile = findElementBySelectors(profileSel);

    if (home) {
      const hClone = home.cloneNode(true);
      // remove save/load from clone (if present) to keep the clone minimal
      Array.from(hClone.querySelectorAll('button, a')).forEach(n => {
        const t = (n.textContent || '').trim().toLowerCase();
        const id = (n.id || '').toLowerCase();
        if (t === 'save' || t === 'load' || id.includes('save') || id.includes('load')) n.remove();
      });
      // ensure cloned elements are not focus-reused to original (prevent accidental form interactions)
      hClone.id = (hClone.id || 'netplayHomeClone') + '-clone';
      // make sure clone is clickable (user might want home)
      hClone.style.pointerEvents = 'auto';
      container.appendChild(hClone);
    }

    if (profile) {
      const pClone = profile.cloneNode(true);
      Array.from(pClone.querySelectorAll('button, a')).forEach(n => {
        const t = (n.textContent || '').trim().toLowerCase();
        const id = (n.id || '').toLowerCase();
        if (t === 'save' || t === 'load' || id.includes('save') || id.includes('load')) n.remove();
      });
      pClone.id = (pClone.id || 'netplayProfileClone') + '-clone';
      pClone.style.pointerEvents = 'auto';
      container.appendChild(pClone);
    }

    // fallback — if neither present, show a basic Profile placeholder (non-invasive)
    if (!home && !profile) {
      const fallback = makeEl('div', { innerText: 'Home | Profile' }, { color: '#fff', fontFamily: 'Arial, sans-serif', fontSize: '13px', pointerEvents: 'none' });
      container.appendChild(fallback);
    }

    document.body.appendChild(container);
  }

/* --- Netplay player label helper (shows 'Player X' on joiners) --- */
function updateNetplayPlayerLabel() {
  try {
    let container = document.getElementById('netplayUIContainer');
    if (!container) {
      // fallback: create small container on top-left
      container = document.createElement('div');
      container.id = 'netplayUIContainer';
      Object.assign(container.style, { position: 'fixed', top: '8px', left: '8px', zIndex: 100001, display: 'flex', gap: '8px', alignItems: 'center', pointerEvents: 'auto' });
      document.body.appendChild(container);
    }
    let lbl = document.getElementById('netplayPlayerLabel');
    if (!lbl) {
      lbl = document.createElement('div');
      lbl.id = 'netplayPlayerLabel';
      Object.assign(lbl.style, { color: '#fff', fontFamily: 'monospace', fontWeight: 'bold', fontSize: '14px', padding: '4px 6px', background: 'rgba(0,0,0,0.4)', borderRadius: '4px', pointerEvents: 'none' });
      container.appendChild(lbl);
    }
    if (npw.role === 'joiner' && typeof npw._assignedSlot === 'number' && npw._assignedSlot !== null) {
      lbl.textContent = 'Player ' + (npw._assignedSlot + 1);
      lbl.style.display = 'block';
    } else {
      lbl.style.display = 'none';
    }
  } catch (e) { console.warn('updateNetplayPlayerLabel failed', e); }
}


  function removeTopLeftUIClone() {
    const c = document.getElementById('netplayUIContainer');
    if (c) c.remove();
  }

  // ===== WebRTC Implementation (exposed globally) =====
  const npw = {
    pc: null, dc: null, localStream: null, videoEl: null, sessionId: null, role: null, _joinHandlers: null
  };

  function npFilePath(sessionId, name) {
    return `http://${SIGNAL_HOST}/netplay/${encodeURIComponent(sessionId)}/${encodeURIComponent(name)}`;
  }
  async function putJson(url, obj) {
    return fetch(url, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(obj) });
  }
  async function readJson(url) {
    try {
      const r = await fetch(url + `?ts=${Date.now()}`, { cache: 'no-store' });
      if (!r.ok) return null;
      return await r.json();
    } catch (e) { return null; }
  }
  function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
  function waitForIceComplete(pc, timeout = 8000) {
    return new Promise(resolve => {
      if (pc.iceGatheringState === 'complete') return resolve();
      const t = setTimeout(() => { pc.onicegatheringstatechange = null; resolve(); }, timeout);
      pc.onicegatheringstatechange = () => {
        if (pc.iceGatheringState === 'complete') { clearTimeout(t); pc.onicegatheringstatechange = null; resolve(); }
      };
    });
  }
// -- begin: netplay local-press tracking (paste near top of netplay code) --
window.__netplay_localPressed = window.__netplay_localPressed || new Set();
window.addEventListener('keydown', (ev) => {
  try { window.__netplay_localPressed.add(ev.key); } catch(e) {}
}, true);
window.addEventListener('keyup', (ev) => {
  try { window.__netplay_localPressed.delete(ev.key); } catch(e) {}
}, true);
// -- end: netplay local-press tracking --

// Expose startHostWebRTC globally
// Expose startHostWebRTC globally (guarantee tracks added before offer; ICE gathered before upload)
// Expose startHostWebRTC globally (guarantee tracks added before offer; ICE gathered before upload)
// Expose startHostWebRTC globally (guarantee tracks added before offer; ICE gathered before upload)
// Expose startHostWebRTC globally (per-slot peerconnections for multiple joiners)
window.startHostWebRTC = async function startHostWebRTC(sessionId, options = { fps: 48, players: 2 }) {
  if (!window.npw) window.npw = { pc: null, dc: null, localStream: null, videoEl: null, sessionId: null, role: null };
  npw.sessionId = sessionId;
  npw.role = 'host';

  // compute player counts immediately so joinerSlots is available to any subsequent logic
  const requestedPlayers = (options && Number(options.players)) ? Number(options.players) : 2;
  const clampedPlayers = Math.min(4, Math.max(2, requestedPlayers));
  const joinerSlots = Math.max(1, clampedPlayers - 1);

  // === RESET previous session artifacts so stale answer files won't block new joiners ===
   async function resetSessionArtifacts(sessionId, maxSlots = 3) {
    const sentinel = { __reset: true, ts: Date.now() };
    const placeholder = { __placeholder: true, ts: Date.now() };
    try {
      // overwrite the answers with a reset sentinel (joiner will ignore __reset)
      for (let i = 1; i <= maxSlots; i++) {
        try { await putJson(npFilePath(sessionId, `answer-p${i}.json`), sentinel); } catch(e){ console.warn('reset: unable to write answer sentinel', e); }
        // optionally overwrite old offers with a placeholder (host will write real offers next)
        try { await putJson(npFilePath(sessionId, `offer-p${i}.json`), placeholder); } catch(e){ /* non-fatal */ }
      }
      // clear the offers manifest so joiners wait for fresh offers
      try { await putJson(npFilePath(sessionId, 'offers.json'), { slots: {} }); } catch(e){ console.warn('reset: unable to clear offers.json', e); }
      // record a session reset marker for debugging/clients
      try { await putJson(npFilePath(sessionId, 'session-meta.json'), { resetAt: Date.now() }); } catch(e){ /* ignore */ }
    } catch (err) { console.warn('resetSessionArtifacts failed', err); }
  }

  // call it (limit is 3 joiners since your code supports up to 3 joiners)
  await resetSessionArtifacts(sessionId, 3);
  async function resetSessionArtifactsNonBlocking(sessionId, maxSlots = 3, attempts = 6, delayMs = 150) {
  for (let i = 0; i < attempts; i++) {
    try {
      // call the existing reset function (which already guards internally)
      await resetSessionArtifacts(sessionId, maxSlots);
      if (i > 0) console.log('[netplay] resetSessionArtifactsNonBlocking: succeeded on attempt', i + 1);
      return;
    } catch (err) {
      console.warn('[netplay] reset attempt', i + 1, 'failed', err);
      // small backoff before retrying
      await wait(delayMs);
    }
  }
  console.warn('[netplay] resetSessionArtifactsNonBlocking: all attempts failed');
}
  // Use a non-blocking scheduled call so we don't race/overwrite host's own freshly-created offers.
  try {
    setTimeout(function(){
      resetSessionArtifactsNonBlocking(sessionId, joinerSlots).catch(function(e){ console.warn('reset helper failed', e); });
    }, 10);
  } catch(e) { console.warn('scheduling reset failed', e); }

  // bookkeeping containers
  npw._pcs = npw._pcs || {};           // slot -> RTCPeerConnection
  npw._dcs = npw._dcs || {};           // slot -> DataChannel (local channel object)
  npw._slotAssigned = npw._slotAssigned || {}; // slot -> boolean connected
  npw._connectedJoiners = 0;
  console.log('[netplay-shim] preparing host for', clampedPlayers, 'players -> preparing', joinerSlots, 'joiner slot(s)');


  // capture canvas media once (if available)
  let canvas = document.querySelector('canvas');
  if (!canvas && window.EJS_emulator && window.EJS_emulator.canvas) canvas = window.EJS_emulator.canvas;
  if (!canvas) {
    alert('Host error: emulator canvas not found. Shared console requires the emulator to render to a canvas.');
    return;
  }

  let mediaStream = null;
  try {
    if (window.EJS_emulator && typeof window.EJS_emulator.collectScreenRecordingMediaTracks === 'function') {
      try { mediaStream = window.EJS_emulator.collectScreenRecordingMediaTracks(canvas, options.fps || 48); } catch (e) { mediaStream = null; }
    }
  } catch (e) { mediaStream = null; }

  try {
    if (!mediaStream) mediaStream = canvas.captureStream(options.fps || 48);
  } catch (e) { console.warn('captureStream failed', e); }

  if (mediaStream) {
    npw.localStream = mediaStream;
  } else {
    console.warn('Host: no mediaStream available for capture; joiner will not receive video/audio.');
  }

  // Create a per-slot RTCPeerConnection, add tracks & datachannel, create offer, upload offer-p{slot}.json
  const offersManifest = { slots: {} };

  for (let slotIndex = 1; slotIndex <= joinerSlots; slotIndex++) {
    try {
      const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
      npw._pcs[slotIndex] = pc;
      pc.oniceconnectionstatechange = () => console.log(`Host PC[${slotIndex}] iceState`, pc.iceConnectionState);
      pc.onconnectionstatechange = () => console.log(`Host PC[${slotIndex}] connState`, pc.connectionState);

      // Create a datachannel so each joiner gets their own input channel
      // Create a datachannel so each joiner gets their own input channel
      const dc = pc.createDataChannel('inputs');
// per-slot last-seq tracking to drop older messages (one map per host slot)
const lastSeqForSlot = {};

      npw._dcs[slotIndex] = dc;
      dc._slot = slotIndex;
      // Set assignedSlot to the emulator's player index:
      // host/emulator-player indices = 0..3, so joiner slots should be 1..3 (slotIndex is already 1..N)
      dc._assignedSlot = slotIndex; // first joiner -> 1 (human Player 2 shown by UI)

      // when joiner opens their side, count them
      dc.onopen = () => {
        console.log(`[Host] datachannel open for slot ${slotIndex} -> assigned player ${dc._assignedSlot}`);
        // notify joiner of their slot explicitly (redundant but useful)
        try { dc.send(JSON.stringify({ type: 'assign-slot', slot: dc._assignedSlot })); } catch(e){}
        if (!npw._slotAssigned[slotIndex]) {
          npw._slotAssigned[slotIndex] = true;
          npw._connectedJoiners = (npw._connectedJoiners || 0) + 1;
          console.log('[netplay-shim] joiner connected -> total connected joiners =', npw._connectedJoiners);
          if (npw._connectedJoiners >= (clampedPlayers - 1)) {
            try { ejsNotify(`All ${clampedPlayers} players have joined (connected ${npw._connectedJoiners} joiner(s)).`); } catch(e){}
          }
        }
      };

      dc.onmessage = (ev) => {
// robustly resolve incomingPlayer & sequence: accept numeric or numeric-string player and track lastSeq
try {
  const e = (arguments && arguments[0]) ? arguments[0] : null;
  let msgObj = e;
  if (typeof msgObj === 'string') {
    try { msgObj = JSON.parse(msgObj); } catch (err) { /* keep string */ }
  }
  const incomingPlayer = (msgObj && (typeof msgObj.player === 'number' || (typeof msgObj.player === 'string' && /^\d+$/.test(msgObj.player))))
    ? Number(msgObj.player)
    : (typeof dc._assignedSlot === 'number' ? dc._assignedSlot : null);
  if (incomingPlayer === null) {
    // cannot resolve player, continue to original handler logic
  } else {
    const evSeq = (msgObj && (typeof msgObj.seq === 'number')) ? msgObj.seq : null;
    if (evSeq !== null) {
      const last = lastSeqForSlot[incomingPlayer] || 0;
      if (evSeq <= last) {
        // stale packet - ignore early
        return;
      }
      lastSeqForSlot[incomingPlayer] = evSeq;
    }
    if (msgObj && typeof msgObj.player === 'undefined') msgObj.player = incomingPlayer;
    if (arguments && arguments.length) arguments[0] = msgObj;
  }
} catch (err) {
  // non-fatal, fall back to original behavior
}

        // route incoming inputs from this joiner into the emulator (reuse existing logic)
        // We'll reuse the same onmessage parsing you had before but scoped to this slot.
        try {
          if (!ev || !ev.data) return;
          const obj = JSON.parse(ev.data);
          if (!obj || obj.type === 'ping') return;
          const events = Array.isArray(obj.events) ? obj.events : (obj.event ? [obj.event] : []);
          for (const e of events) {
            const incomingPlayer = (typeof e.player === 'number') ? Number(e.player) : dc._assignedSlot;
            if (incomingPlayer === 0) continue;
            // try optimized path
            if (typeof e.buttonIndex === 'number' && isFinite(e.buttonIndex)) {
              const numericValue = (typeof e.value === 'number') ? e.value : (String(e.type || '').toLowerCase().includes('down')?1:0);
              try {
                if (typeof window.EJS_handleRemoteInputs === 'function') { window.EJS_handleRemoteInputs({ events: [{ player: incomingPlayer, buttonIndex: Number(e.buttonIndex), value: numericValue, seq: e.seq }] }); continue; }
                if (typeof window.EJS_simulateInput === 'function') { window.EJS_simulateInput(incomingPlayer, Number(e.buttonIndex), numericValue); continue; }
              } catch(_) {}
              if (typeof window.netplayInject === 'function') window.netplayInject(incomingPlayer, Number(e.buttonIndex), numericValue);
            } else {
              // fallback: forward as-is
              if (typeof window.EJS_handleRemoteInputs === 'function') window.EJS_handleRemoteInputs({ events: [Object.assign({}, e, { player: incomingPlayer })] });
            }
          }
        } catch (err) { if (window.__NETPLAY_SHIM_VERBOSE) console.warn('slot dc.onmessage error', err); }
      };
      dc.onclose = () => {
        console.log(`[Host] datachannel closed for slot ${slotIndex}`);
        if (npw._slotAssigned[slotIndex]) {
          npw._slotAssigned[slotIndex] = false;
          npw._connectedJoiners = Math.max(0, (npw._connectedJoiners || 0) - 1);
        }
      };

      // add tracks for this pc (share same mediaStream references)
      if (mediaStream) {
        const vids = mediaStream.getVideoTracks() || [];
        const auds = mediaStream.getAudioTracks() || [];
        for (const t of vids) try { pc.addTrack(t, mediaStream); } catch(e){ console.warn('addTrack video failed', e); }
        for (const t of auds) try { pc.addTrack(t, mediaStream); } catch(e){ console.warn('addTrack audio failed', e); }
      }

      // create offer and publish offer-p{slot}.json
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await waitForIceComplete(pc, 8000);
      try {
        await putJson(npFilePath(sessionId, `offer-p${slotIndex}.json`), pc.localDescription);
        offersManifest.slots[slotIndex] = { offer: `offer-p${slotIndex}.json`, status: 'available' };
        console.log('[Host] uploaded offer-p' + slotIndex);
      } catch (e) {
        console.warn('[Host] failed to write offer-p' + slotIndex, e);
      }
    } catch (e) {
      console.warn('startHostWebRTC per-slot error for slot', slotIndex, e);
    }
  } // end for slots

  // publish offers manifest to let joiners know what slots exist
  try {
    await putJson(npFilePath(sessionId, 'offers.json'), offersManifest);
  } catch(e){ console.warn('failed to write offers.json', e); }

  // poll for answers for each slot
  for (let slotIndex = 1; slotIndex <= joinerSlots; slotIndex++) {
    ((slot) => {
// poll for answers for each slot (replace the inner body with this validated logic)
const poll = setInterval(async () => {
  try {
    const ans = await readJson(npFilePath(sessionId, `answer-p${slot}.json`));
    // no file yet
    if (!ans) return;

    // ignore server-written reset / placeholder markers (these are not real answers)
    if (ans.__reset || ans.__placeholder) {
      if (window.__NETPLAY_SHIM_VERBOSE) console.log('[Host] ignoring sentinel/placeholder for slot', slot, ans);
      return;
    }

    // validate shape: must look like an RTCSessionDescriptionInit
    if (typeof ans !== 'object' || typeof ans.type !== 'string' || typeof ans.sdp !== 'string') {
      console.warn('[Host] ignoring non-session-description payload for slot', slot, ans);
      return;
    }

    // now we have something that at least looks like an answer -> proceed
    clearInterval(poll);
    try {
      const pc = npw._pcs[slot];
      if (pc) {
        await pc.setRemoteDescription(ans);
        console.log('[Host] applied remote answer for slot', slot);
        // update manifest (best-effort)
        try {
          offersManifest.slots[slot].status = 'connected';
          await putJson(npFilePath(sessionId, 'offers.json'), offersManifest);
        } catch (_) {}
      }
    } catch (e) {
      console.warn('[Host] failed to setRemoteDescription for slot', slot, e);
    }
  } catch (e) {
    // ignore transient read errors
  }
}, 1000);
    })(slotIndex);
  }

  // store total slots so other code can reference it
  npw._totalSlots = joinerSlots;
  return true;
}; // end startHostWebRTC (per-slot)

 // end startHostWebRTC



// Expose stopHostWebRTC globally
// Expose stopHostWebRTC globally — close per-slot PCs + cleanup
window.stopHostWebRTC = function stopHostWebRTC() {
  try {
    if (npw) {
      // close per-slot pcs
      if (npw._pcs) {
        for (const k of Object.keys(npw._pcs)) {
          try { npw._pcs[k].close(); } catch(e){}
        }
      }
      // stop local stream tracks
      if (npw.localStream) {
        try { for (const t of npw.localStream.getTracks()) t.stop(); } catch(e) {}
      }
      // remove video element if present
      if (npw.videoEl) {
        try { npw.videoEl.pause(); npw.videoEl.srcObject = null; npw.videoEl.remove(); } catch(e){}
      }
    }
  } catch (e) { console.warn(e); }
  // cleanup object
  npw.pc = null; npw.dc = null; npw._pcs = null; npw._dcs = null; npw.localStream = null; npw.videoEl = null;
  npw.role = null; npw.sessionId = null; npw._slotAssigned = null; npw._connectedJoiners = 0;
  console.log('Host stopped (all slot PCs closed).');
};


// Expose joinWebRTC globally
// Expose joinWebRTC globally (simplified: offer/answer only, no candidates.json)
// Expose joinWebRTC globally (slot-aware: picks first available slot from offers.json)
window.joinWebRTC = async function joinWebRTC(sessionId) {
  npw.sessionId = sessionId;
  npw.role = 'joiner';

  // Wait for offers.json to appear, then pick lowest slot with offer present and no answer yet
  let offers = null;
  const start = Date.now();
  while (!offers && (Date.now() - start) < 20000) {
    offers = await readJson(npFilePath(sessionId, 'offers.json'));
    if (!offers) await wait(800);
  }
  if (!offers) { alert('No host offers found. Ask host to start sharing.'); return; }

  // find first available slot
  // find first available slot (ignore host reset sentinels / placeholders)
  let chosenSlot = null;
  for (const s of Object.keys(offers.slots || {}).map(x=>Number(x)).sort((a,b)=>a-b)) {
    // check if corresponding answer file already exists (avoid racing)
    const existingAnswer = await readJson(npFilePath(sessionId, `answer-p${s}.json`));
    // treat server-side reset sentinel as "no answer"
    if (existingAnswer && !existingAnswer.__reset) {
      // if an actual answer exists (not a reset sentinel), skip the slot
      continue;
    }
    // ensure the offer is a real offer (ignore placeholder-written offers)
    const offerObj = await readJson(npFilePath(sessionId, `offer-p${s}.json`));
    if (!offerObj || offerObj.__placeholder || offerObj.__reset) continue;
    chosenSlot = s;
    break;
  }

  if (!chosenSlot) {
    alert('No available join slots found. Host is full.');
    return;
  }


  // fetch the slot-specific offer
  const offer = await readJson(npFilePath(sessionId, `offer-p${chosenSlot}.json`));
  if (!offer) { alert('Could not fetch slot offer.'); return; }

  // create PC and answer
  const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
  npw.pc = pc;

 // ontrack -> show host video
pc.ontrack = (ev) => {
  try {
    let video = document.getElementById('netplayVideo');

    if (!video) {
      // create the main video element - start muted so iOS/Safari will allow autoplay
      video = makeEl('video',
        { id: 'netplayVideo', autoplay: true, playsInline: true, muted: true },
        {
          position: 'fixed', left: '0', top: '0', width: '100vw', height: '100vh', zIndex: 100000,
          border: '0', background: '#000', objectFit: 'contain', pointerEvents: 'none', userSelect: 'none'
        }
      );

      // clickable overlay (host dblclick fullscreen + clicks to unmute)
      const overlay = makeEl('div', { id: 'netplayOverlay' }, {
        position: 'fixed', left: '0', top: '0', width: '100vw', height: '100vh',
        zIndex: 100002, background: 'transparent', cursor: 'default', pointerEvents: 'auto'
      });

   // --- dblclick fullscreen handler (preserves UI clone) ---
overlay.addEventListener('dblclick', async (ev) => {
  ev.preventDefault();
  try {
    // ensure the top-left UI clone exists (uses your existing helper)
    try { installTopLeftUIClone(); } catch (err) { console.warn('installTopLeftUIClone failed', err); }

    // find or create a fullscreen container
    let fsContainer = document.getElementById('netplayFullscreenContainer');
    const originalParent = video.parentElement;
    const originalNext = video.nextSibling;

    if (!fsContainer) {
      fsContainer = document.createElement('div');
      fsContainer.id = 'netplayFullscreenContainer';
      Object.assign(fsContainer.style, {
        position: 'fixed',
        left: '0', top: '0', width: '100vw', height: '100vh',
        zIndex: 100000, background: '#000', display: 'flex',
        alignItems: 'center', justifyContent: 'center', overflow: 'hidden',
        pointerEvents: 'auto'
      });

      // ensure the video fits inside container
      video.style.position = 'relative';
      video.style.width = '100%';
      video.style.height = '100%';
      video.style.objectFit = 'contain';
      video.style.pointerEvents = 'none'; // keep UI clickable over video

      // append video into container
      fsContainer.appendChild(video);

      // append the cloned top-left UI (if present); installTopLeftUIClone creates #netplayUIContainer
      const uiClone = document.getElementById('netplayUIContainer');
      if (uiClone) {
        // keep UI on top
        uiClone.style.zIndex = 100001;
        // ensure it stays positioned within the fullscreen container
        fsContainer.appendChild(uiClone);
      }

      document.body.appendChild(fsContainer);
    } else {
      // If container exists but video is not inside, move it there
      if (video.parentElement !== fsContainer) fsContainer.appendChild(video);
      // make sure UI clone is present and on top
      const uiClone = document.getElementById('netplayUIContainer');
      if (uiClone && uiClone.parentElement !== fsContainer) fsContainer.appendChild(uiClone);
    }

    // Listen for fullscreen changes so we can restore the DOM when exiting
    const onFsChange = () => {
      if (!document.fullscreenElement) {
        // move video back to original parent/location
        try {
          if (originalParent) {
            if (originalNext) originalParent.insertBefore(video, originalNext);
            else originalParent.appendChild(video);
            // restore any inline styles you prefer
            video.style.position = 'fixed';
            video.style.left = '0';
            video.style.top = '0';
            video.style.width = '100vw';
            video.style.height = '100vh';
            video.style.objectFit = 'contain';
            video.style.pointerEvents = 'none';
          }
        } catch (err) { console.warn('restore video failed', err); }

        // move ui clone back into document.body (installTopLeftUIClone can recreate it if needed)
        try {
          const uiClone = document.getElementById('netplayUIContainer');
          if (uiClone && uiClone.parentElement !== document.body) document.body.appendChild(uiClone);
        } catch (err) {}

        // remove container if empty
        try {
          const fs = document.getElementById('netplayFullscreenContainer');
          if (fs && fs.childElementCount === 0) fs.remove();
        } catch (err) {}

        document.removeEventListener('fullscreenchange', onFsChange);
      }
    };
    document.addEventListener('fullscreenchange', onFsChange);

    // toggle fullscreen on the container (not on the video element)
    if (!document.fullscreenElement) {
      await fsContainer.requestFullscreen();
    } else {
      await document.exitFullscreen();
    }
  } catch (e) {
    console.error('netplay fullscreen toggle error', e);
    // fallback: try video fullscreen as last resort
    try { if (!document.fullscreenElement) await video.requestFullscreen(); else await document.exitFullscreen(); } catch(err) {}
  }
});
// end double click handler
      // Unmute control: show a small unmute button until user interacts
      const unmuteBtn = makeEl('button',
        { id: 'netplayUnmuteBtn', innerText: 'Unmute' },
        {
          position: 'fixed', right: '12px', top: '12px', zIndex: 100003, padding: '8px 10px',
          borderRadius: '6px', border: 'none', background: 'rgba(0,0,0,0.6)', color: '#fff',
          fontSize: '14px', cursor: 'pointer', pointerEvents: 'auto'
        }
      );
      unmuteBtn.setAttribute('aria-label', 'Unmute video');

      // Unmute helper — triggered by a user gesture
      const doUnmute = (gestureEvent) => {
        try {
          video.muted = false;
          try { video.play().catch(()=>{}); } catch(e){}
        } catch (e) { console.warn('doUnmute failed', e); }

        try { if (unmuteBtn && unmuteBtn.parentElement) unmuteBtn.remove(); } catch (e) {}
        window.removeEventListener('touchstart', doUnmute);
        window.removeEventListener('pointerdown', doUnmute);
        window.removeEventListener('keydown', doUnmute);
      };

      // Attach one-time gesture listeners (first real gesture unmute)
      window.addEventListener('touchstart', doUnmute, { once: true, passive: true });
      window.addEventListener('pointerdown', doUnmute, { once: true });
      window.addEventListener('keydown', doUnmute, { once: true });

      unmuteBtn.addEventListener('click', doUnmute);

      // Append elements to DOM
      document.body.appendChild(video);
      document.body.appendChild(overlay);
      document.body.appendChild(unmuteBtn);

      // Try to start playback muted (this should succeed on iOS since it's muted)
      video.playsInline = true;
      video.autoplay = true;
      try { video.addEventListener('loadedmetadata', () => { try { video.play().catch(()=>{}); } catch(e){} }); } catch (e) {}
    }

    // -- keep stream assignment in the same place your original file expects --
    const stream = (ev.streams && ev.streams[0]) ? ev.streams[0] : new MediaStream([ev.track]);
    try { video.srcObject = stream; } catch (e) { video.src = URL.createObjectURL(stream); }
    npw.videoEl = video;

  } catch (e) { console.warn('joinWebRTC ontrack error', e); }
};


  // datachannel from host will arrive via ondatachannel
  pc.ondatachannel = (evt) => {
    const dc = evt.channel;
// per-slot last-seq tracking to drop older messages (one map per host slot)
const lastSeqForSlot = {};

    npw.dc = dc;
    dc.onopen = () => { console.log('Joiner DC open (slot ' + chosenSlot + ')'); attachJoinerHandlers(); };
    dc.onmessage = (ev) => {
// robustly resolve incomingPlayer & sequence: accept numeric or numeric-string player and track lastSeq
try {
  const e = (arguments && arguments[0]) ? arguments[0] : null;
  let msgObj = e;
  if (typeof msgObj === 'string') {
    try { msgObj = JSON.parse(msgObj); } catch (err) { /* keep string */ }
  }
  const incomingPlayer = (msgObj && (typeof msgObj.player === 'number' || (typeof msgObj.player === 'string' && /^\d+$/.test(msgObj.player))))
    ? Number(msgObj.player)
    : (typeof dc._assignedSlot === 'number' ? dc._assignedSlot : null);
  if (incomingPlayer === null) {
    // cannot resolve player, continue to original handler logic
  } else {
    const evSeq = (msgObj && (typeof msgObj.seq === 'number')) ? msgObj.seq : null;
    if (evSeq !== null) {
      const last = lastSeqForSlot[incomingPlayer] || 0;
      if (evSeq <= last) {
        // stale packet - ignore early
        return;
      }
      lastSeqForSlot[incomingPlayer] = evSeq;
    }
    if (msgObj && typeof msgObj.player === 'undefined') msgObj.player = incomingPlayer;
    if (arguments && arguments.length) arguments[0] = msgObj;
  }
} catch (err) {
  // non-fatal, fall back to original behavior
}

      try {
        const msg = JSON.parse(ev.data);
        if (msg && msg.type === 'assign-slot') {
          npw._assignedSlot = (typeof msg.slot === 'number') ? msg.slot : null;
          console.log('Joiner: assigned slot ->', npw._assignedSlot);
          try { updateNetplayPlayerLabel(); } catch (e) {}
        }
      } catch (e) {}
    };
  };

  // apply host offer
  try { await pc.setRemoteDescription(offer); } catch (e) { console.warn('join setRemoteDescription failed', e); }

  // create & upload answer
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await waitForIceComplete(pc, 8000);
  try { await putJson(npFilePath(sessionId, `answer-p${chosenSlot}.json`), pc.localDescription); } catch (e) { console.warn('join put answer failed', e); }
  console.log('Joiner: answer written for slot', chosenSlot);

  // attach handlers readiness
  function attachJoinerHandlers() {
    if (!npw.dc || npw.dc.readyState !== 'open') return setTimeout(attachJoinerHandlers, 100);
    if (typeof npw._assignedSlot === 'undefined') npw._assignedSlot = null;

    // keyboard -> send input events over the slot channel
    // --- keyboard passthrough + mapping to numeric buttonIndex (restored & fixed) ---
    const sendEvent = (evt) => {
      try {
        if (typeof npw._sendSeq === 'undefined') npw._sendSeq = 1;
        // use assigned slot from host if present, otherwise use the chosenSlot we used to pick the offer
        const slot = (typeof npw._assignedSlot === 'number') ? npw._assignedSlot : chosenSlot;
        const payload = {
          seq: ++npw._sendSeq,
          events: [{
            type: evt.type,
            key: evt.key,
            code: evt.code || '',
            keyCode: evt.keyCode || 0,
            timestamp: Date.now(),
            player: slot
          }]
        };

        // map keyboard key -> EJS_defaultControls[slot] index if possible (robust)
        try {
          if (window.EJS_defaultControls && typeof slot !== 'undefined' && slot !== null) {
            const ctrlMap = window.EJS_defaultControls[slot];
            if (ctrlMap) {
              const keyLower = String(evt.key || '').toLowerCase();
              for (const k of Object.keys(ctrlMap)) {
                try {
                  const entry = ctrlMap[k] || {};
                  const v = (entry.value) ? String(entry.value) : '';
                  const v2 = (entry.value2) ? String(entry.value2) : '';
                  if (!v && !v2) continue;

                  // Accept exact match, case-insensitive match, or a variety of legacy "P#_<key>" labels.
                  const legacyA = 'P' + slot + '_' + evt.key;
                  const legacyB = 'P' + (slot + 1) + '_' + evt.key; // accept either convention
                  const legacyC = 'P' + (slot - 1) + '_' + evt.key; // be permissive

                  if (
                    v === evt.key ||
                    (v && v.toLowerCase() === keyLower) ||
                    v2 === evt.key ||
                    (v2 && v2.toLowerCase() === keyLower) ||
                    v === legacyA || v === legacyB || v === legacyC ||
                    v2 === legacyA || v2 === legacyB
                  ) {
                    payload.events[0].buttonIndex = Number(k);
                    break;
                  }
                } catch (e){}
              }
            }
          }
        } catch (e) { /* ignore mapping errors */ }

        // send over the per-slot datachannel (npw.dc set in pc.ondatachannel)
        if (npw.dc && npw.dc.readyState === 'open') {
          npw.dc.send(JSON.stringify(payload));
        }
      } catch (e) { /* ignore send errors */ }
};

    window.addEventListener('keydown', sendEvent, { capture: false });
    window.addEventListener('keyup', sendEvent, { capture: false });
    npw._joinHandlers = sendEvent;

    // Make chosenSlot visible on npw in case optimizedPoll runs where chosenSlot isn't lexically visible
    try { if (typeof chosenSlot !== 'undefined') npw._chosenSlot = chosenSlot; } catch (e) {}

    // --- optimized gamepad polling (low-cost) ---
    function getCtrlIndexForSemantic(slot, semantic) {
      try {
        if (!window.EJS_defaultControls) return undefined;
        const map = window.EJS_defaultControls[slot] || {};
        for (const k of Object.keys(map)) {
          const entry = map[k] || {};
          const v1 = (entry.value) ? String(entry.value) : '';
          const v2 = (entry.value2) ? String(entry.value2) : '';
          if (!v1 && !v2) continue;
          if (v1 && v1.indexOf(semantic) === 0) return Number(k);
          if (v2 && v2.indexOf(semantic) === 0) return Number(k);
        }
        return undefined;
      } catch (e) { return undefined; }
    }

    const lastTimestamps = [];
    const lastButtonState = {};
    const lastAxisDir = {};
    const AXIS_THRESHOLD = 0.5;

    if (typeof npw._sendSeq === 'undefined') npw._sendSeq = 1;
    npw._gamepadPollActive = true;

    function sendGamepadEvent(slot, buttonIndex, value) {
      try {
        if (typeof buttonIndex !== 'number' || !isFinite(buttonIndex)) return;
        const payload = {
          seq: ++npw._sendSeq,
          events: [{
            type: 'gamepad',
            player: slot,
            buttonIndex: Number(buttonIndex),
            value: Number(value),
            timestamp: Date.now()
          }]
        };
        // debug: show mapping in console so we can see which slot each gamepad event goes to
        console.log('[joiner] sendGamepadEvent ->', { slot, buttonIndex, value });
        if (npw.dc && npw.dc.readyState === 'open') {
          npw.dc.send(JSON.stringify(payload));
        }
      } catch (e) { /* ignore send errors */ }
    }

    function optimizedPoll() {
      if (!npw._gamepadPollActive) return;

      if (document.hidden) {
        npw._gamepadRafId = window.requestAnimationFrame(optimizedPoll);
        return;
      }

      try {
        const gps = (navigator.getGamepads) ? navigator.getGamepads() : [];
        for (let g = 0; g < (gps ? gps.length : 0); g++) {
          const gp = gps[g];
          if (!gp) continue;

          if (typeof gp.timestamp === 'number') {
            if (lastTimestamps[g] === gp.timestamp) continue;
            lastTimestamps[g] = gp.timestamp;
          }

          // prefer assignedSlot, then lexical chosenSlot (visible here), then npw._chosenSlot, then fallback 1
          const slot = (typeof npw._assignedSlot === 'number')
            ? npw._assignedSlot
            : (typeof chosenSlot === 'number'
                ? chosenSlot
                : (typeof npw._chosenSlot === 'number' ? npw._chosenSlot : 1));

          // Buttons
// map browser gamepad button index -> semantic name (v2 in EJS_defaultControls)
const GAMEPAD_BUTTON_TO_SEMANTIC = {
  0: 'BUTTON_1',    // A
  1: 'BUTTON_2',    // B
  2: 'BUTTON_3',    // X
  3: 'BUTTON_4',    // Y
  4: 'LEFT_TOP_SHOULDER',
  5: 'RIGHT_TOP_SHOULDER',
  6: 'LEFT_BOTTOM_SHOULDER',
  7: 'RIGHT_BOTTOM_SHOULDER',
  8: 'SELECT',      // Back
  9: 'START',       // Start
  10: 'LEFT_STICK',
  11: 'RIGHT_STICK',
  12: 'DPAD_UP',
  13: 'DPAD_DOWN',
  14: 'DPAD_LEFT',
  15: 'DPAD_RIGHT'
};

// Buttons: only act on state change
const buttons = gp.buttons || [];
for (let b = 0; b < buttons.length; b++) {
  const pressed = !!(buttons[b] && (buttons[b].pressed || (typeof buttons[b].value === 'number' && buttons[b].value > 0.5)));
  const key = `${g}:${b}`;
  if (lastButtonState[key] !== pressed) {
    lastButtonState[key] = pressed;
    try {
      // Map this specific physical button index -> semantic -> control index
      const semantic = GAMEPAD_BUTTON_TO_SEMANTIC[b];
      if (!semantic) {
        // unknown mapping, fall back to sending raw button index
        sendGamepadEvent(slot, b, pressed ? 1 : 0);
        continue;
      }
      const ctrlIdx = getCtrlIndexForSemantic(slot, semantic);
      if (typeof ctrlIdx === 'number') {
        sendGamepadEvent(slot, ctrlIdx, pressed ? 1 : 0);
      } else {
        // If the semantic isn't mapped in EJS_defaultControls, fallback to raw button index
        sendGamepadEvent(slot, b, pressed ? 1 : 0);
      }
    } catch (e) {
      // On any error, fallback to sending the raw button index so input still works
      sendGamepadEvent(slot, b, pressed ? 1 : 0);
    }
  }
}

          // Axes -> directional states
          const axes = gp.axes || [];
         for (let a = 0; a < axes.length; a++) {
  const raw = typeof axes[a] === 'number' ? axes[a] : 0;
  // scale to emulator resolution (-32767..32767)
  const scaled = Math.round(Math.max(-1, Math.min(1, raw)) * 0x7fff);
  const key = `${g}:axis:${a}`;
  const prev = (typeof lastAxisDir[key] === 'number') ? lastAxisDir[key] : 0;

  // Only send if value changed (avoid spamming identical values)
  if (scaled !== prev) {
    lastAxisDir[key] = scaled;
    try {
      // map axis index -> semantic pairs
      let plusSem = null, minusSem = null;
      if (a === 0) { plusSem = 'LEFT_STICK_X:+1'; minusSem = 'LEFT_STICK_X:-1'; }
      else if (a === 1) { plusSem = 'LEFT_STICK_Y:+1'; minusSem = 'LEFT_STICK_Y:-1'; }
      else if (a === 2) { plusSem = 'RIGHT_STICK_X:+1'; minusSem = 'RIGHT_STICK_X:-1'; }
      else if (a === 3) { plusSem = 'RIGHT_STICK_Y:+1'; minusSem = 'RIGHT_STICK_Y:-1'; }

      // Resolve mapped indices once and reuse
      const idxPlus = plusSem ? getCtrlIndexForSemantic(slot, plusSem) : null;
      const idxMinus = minusSem ? getCtrlIndexForSemantic(slot, minusSem) : null;
      const hasMapping = (typeof idxPlus === 'number' || typeof idxMinus === 'number');

      if (hasMapping) {
        if (scaled > 0) {
          if (typeof idxPlus === 'number') sendGamepadEvent(slot, idxPlus, scaled);
          if (typeof idxMinus === 'number') sendGamepadEvent(slot, idxMinus, 0);
        } else if (scaled < 0) {
          if (typeof idxMinus === 'number') sendGamepadEvent(slot, idxMinus, -scaled);
          if (typeof idxPlus === 'number') sendGamepadEvent(slot, idxPlus, 0);
        } else {
          // neutral
          if (typeof idxPlus === 'number') sendGamepadEvent(slot, idxPlus, 0);
          if (typeof idxMinus === 'number') sendGamepadEvent(slot, idxMinus, 0);
        }
      } else {
        // fallback compatibility for unmapped axes (preserve original base ids)
        const base = 1000 + (a * 2);
        if (scaled > 0) { sendGamepadEvent(slot, base, scaled); sendGamepadEvent(slot, base + 1, 0); }
        else if (scaled < 0) { sendGamepadEvent(slot, base, 0); sendGamepadEvent(slot, base + 1, -scaled); }
        else { sendGamepadEvent(slot, base, 0); sendGamepadEvent(slot, base + 1, 0); }
      }
    } catch (e) {}
  }
}
        }
      } catch (e) {
        // ignore polling errors
      }

      try {
        npw._gamepadRafId = window.requestAnimationFrame(optimizedPoll);
      } catch (e) {
        setTimeout(optimizedPoll, 1000 / 30);
      }
    }

    try {
      if (!npw._gamepadRafId) npw._gamepadRafId = window.requestAnimationFrame(optimizedPoll);
    } catch (e) {
      setTimeout(optimizedPoll, 1000 / 30);
    }

    function onGpConnect() {
      if (!npw._gamepadPollActive) {
        npw._gamepadPollActive = true;
        if (!npw._gamepadRafId) npw._gamepadRafId = window.requestAnimationFrame(optimizedPoll);
      }
    }
    function onGpDisconnect() {
      // no-op
    }
    window.addEventListener('gamepadconnected', onGpConnect);
    window.addEventListener('gamepaddisconnected', onGpDisconnect);

    npw._stopGamepadPolling = function() {
      try {
        npw._gamepadPollActive = false;
        if (npw._gamepadRafId) {
          window.cancelAnimationFrame(npw._gamepadRafId);
          npw._gamepadRafId = null;
        }
        window.removeEventListener('gamepadconnected', onGpConnect);
        window.removeEventListener('gamepaddisconnected', onGpDisconnect);
      } catch (e) {}
    };
  }


  return pc;
}; // end joinWebRTC


// Expose leaveWebRTC globally
window.leaveWebRTC = async function leaveWebRTC() {
  try {
    if (npw._joinHandlers) {
      window.removeEventListener('keydown', npw._joinHandlers);
      window.removeEventListener('keyup', npw._joinHandlers);
    }

    // If an overlay exists, remove it
    const ov = document.getElementById('netplayOverlay');
    if (ov) ov.remove();

    // If the video is in fullscreen, exit it first
    try {
      if (document.fullscreenElement) {
        // if the fullscreen element is the video or overlay, exit
        await (document.exitFullscreen ? document.exitFullscreen() : Promise.resolve());
      }
    } catch (e) { /* ignore */ }

    if (npw.videoEl) {
      try {
        npw.videoEl.pause();
        npw.videoEl.srcObject = null;
      } catch (e) { /* ignore */ }
      try { npw.videoEl.remove(); } catch(e){}
    }

    removeTopLeftUIClone();

    if (npw.dc) try { npw.dc.close(); } catch(e){}
    if (npw.pc) try { npw.pc.close(); } catch(e){}
  } catch (e) { console.warn(e); }

  npw.pc = npw.dc = npw.videoEl = null;
  npw.role = null; npw.sessionId = null; npw._joinHandlers = null;
  console.log('Left session.');
};

// Shared Console click wiring (starts host/join flows and closes dialog)
// Replace the existing '#toggleShared' onclick handler with this.
// NOTE: This prompts for players FIRST, then asks for session ID.
(function(){
  const toggleEl = netplayDialog.querySelector('#toggleShared');
  if (!toggleEl) return;

  toggleEl.onclick = async () => {
    // toggle state & hide dialog
    sharedConsoleEnabled = !sharedConsoleEnabled;
    linkTradeEnabled = false;
    updateNetplayVisuals();
    netplayDialog.style.display = 'none';

    // If disabling, stop any existing session
    if (!sharedConsoleEnabled) {
      try { if (npw && npw.role === 'host') stopHostWebRTC(); } catch(e) {}
      try { if (npw && npw.role === 'joiner') leaveWebRTC(); } catch(e) {}
      if (window.npw) { npw.role = npw.sessionId = null; }
      return;
    }

    // Must have chosen host/join mode first
    if (!netplayMode) {
      alert('Pick Host or Join first.');
      sharedConsoleEnabled = false;
      updateNetplayVisuals();
      return;
    }

    // HOST PATH: prompt for players first, then session id
    if (netplayMode === 'hosting') {
      // Prompt host for number of players (loop until valid or cancelled)
      let players = null;
      while (players === null) {
        const raw = prompt('How many players will play? (enter 2, 3 or 4)', '2');
        if (raw === null) { // user cancelled prompt
          sharedConsoleEnabled = false;
          updateNetplayVisuals();
          return;
        }
        const p = parseInt(raw, 10);
        if ([2, 3, 4].includes(p)) {
          players = p;
        } else {
          alert('Please enter 2, 3 or 4.');
        }
      }

      // Now ask for session id (auto-generate if blank)
      let sid = prompt('Enter session ID (leave blank to auto-generate):', '');
      if (sid === null) { // cancelled -> stop
        sharedConsoleEnabled = false;
        updateNetplayVisuals();
        return;
      }
      if (!sid) sid = 'ss-' + Math.random().toString(36).slice(2, 9);

      // Start hosting with requested players
      try {
        await window.startHostWebRTC(sid, { fps: 48, players });
        ejsNotify(`Hosting session "${sid}" for ${players} players.`);
      } catch (e) {
        console.error(e);
        alert('Host start failed. See console.');
        sharedConsoleEnabled = false;
        updateNetplayVisuals();
      }

      return;
    }

// JOINER PATH: just ask for session id and join
if (netplayMode === 'joining' || netplayMode === 'joiner') {
  let sid = prompt('Enter session ID to join:', '');
  if (sid === null) { // cancelled
    sharedConsoleEnabled = false;
    updateNetplayVisuals();
    return;
  }
  if (!sid) {
    alert('No session ID provided. Aborting join.');
    sharedConsoleEnabled = false;
    updateNetplayVisuals();
    return;
  }

  try {
    await window.joinWebRTC(sid);
    ejsNotify(`Joining session "${sid}".`);

    // ---- PAUSE local emulator on joiner device ----
    if (window.EJS_emulator && typeof window.EJS_emulator.pause === 'function') {
      try {
        // true -> don't trigger UI/remote updates (matches other netplay uses)
        window.EJS_emulator.pause(true);

        if (typeof window.EJS_emulator.displayMessage === 'function') {
          window.EJS_emulator.displayMessage('Paused (joiner mode) — using host stream');
        } else {
          ejsNotify('Local emulator paused (joiner mode).');
        }
      } catch (pauseErr) {
        console.warn('Failed to pause local emulator on join:', pauseErr);
      }
    }
  } catch (e) {
    console.error(e);
    alert('Join failed. See console.');
    sharedConsoleEnabled = false;
    updateNetplayVisuals();
  }
}
  };
})();

// Disconnect button
netplayDialog.querySelector('#disconnectBtn').onclick = () => {
  if (npw.role === 'host') window.stopHostWebRTC();
  if (npw.role === 'joiner') window.leaveWebRTC();
  netplayMode = null; sharedConsoleEnabled = false; linkTradeEnabled = false; updateNetplayVisuals();
  netplayDialog.style.display = 'none';
};

// Keep visuals up-to-date for other controls
updateNetplayVisuals();

// expose reset function for other code (optional)
window.resetNetplay = function() {
  if (npw.role === 'host') window.stopHostWebRTC();
  if (npw.role === 'joiner') window.leaveWebRTC();
  netplayDialog.style.display = 'none';
  netplayMode = null; sharedConsoleEnabled = false; linkTradeEnabled = false; updateNetplayVisuals();
};
})();

document.body.appendChild(netplayButton);
// Guidebook Button 00000000000
const guideButton = document.createElement("a");
guideButton.innerHTML  = "&#x1F56E;";
Object.assign(guideButton.style, {
    position: "fixed",
    top: "36px",
    right: `56px`,
    zIndex: "9999",
    padding: "1px 2px",
    background: "transparent",
    color: "white",
    border: "1px solid white",
    borderRadius: "2px",
    textDecoration: "none",
    fontFamily: "Arial, sans-serif",
    fontSize: "16px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    boxShadow: "0 2px 2px rgba(0,0,0,0.3)",
    cursor: "pointer"
});
guideButton.addEventListener("click", (e) => {
    e.preventDefault();
    const rom = romParam.split('?')[0];
    const base = rom.split('.')[0];
const url = `http://${serverIP}/guidebooks.html?Guidebook=${base}Guidebook`;
    const iframe = document.getElementById("guideIframe");
    iframe.src = url;
    document.getElementById("guideContainer").style.display = "block";
});
document.body.appendChild(guideButton);

// Guidebook Iframe Container
const guideContainer = document.createElement("div");
guideContainer.id = "guideContainer";
Object.assign(guideContainer.style, {
    display: "none",
    position: "fixed",
    top: "1%",
    left: "1%",
    width: "98%",
    height: "98%",
    background: "rgba(0,0,0,0.8)",
    zIndex: "10001"
});
const guideIframe = document.createElement("iframe");
guideIframe.id = "guideIframe";
Object.assign(guideIframe.style, {
    width: "100%",
    height: "100%",
    border: "none",
    borderRadius: "8px"
});
// â€”â€”â€” Guidebook â€”â€”â€”
guideContainer.appendChild(guideIframe);

// 1) Make the container transparent
guideContainer.style.background = "transparent";

// 2) Allow the iframe to render with a transparent background
guideIframe.style.background = "transparent";
guideIframe.setAttribute("allowTransparency", "true");

const closeGuide = document.createElement("button");
closeGuide.textContent = "";

Object.assign(closeGuide.style, {
  position:    "absolute",
  top:         "-5px",
  right:       "13px",
  width:       "28px",
  height:      "28px",
  fontSize:    "16px",
  lineHeight:  "28px",
  textAlign:   "center",
  background:  "transparent",  // button itself is transparent
  color:       "#fff",
  border:      "none",
  borderRadius:"4px",
  cursor:      "pointer",
  zIndex:      "10002"
});

closeGuide.addEventListener("click", () => {
  guideContainer.style.display = "none";
  guideIframe.src = "";
});

guideContainer.appendChild(closeGuide);
document.body.appendChild(guideContainer);
// â€”â€”â€” DROPâ€‘IN REPLACEMENT END â€”â€”â€”
// â€”â€”â€” DROPâ€‘IN REPLACEMENT END â€”â€”â€”
// â€”â€”â€” DROPâ€‘IN REPLACEMENT END â€”â€”â€”
// Fullscreen Button
                const fullscreenButton = document.createElement("a");
                fullscreenButton.href = "#";
                fullscreenButton.innerText = "Fullscreen";
                fullscreenButton.style.cssText = `
                    position: fixed;
                    top: 5px;
                    right: 5px;
                    z-index: 9999;
                    padding: 3px 3px;
                    background: #6A5F7D;
                    color: white;
                    border-radius: 3px;
                    text-decoration: none;
                    font-family: Arial, sans-serif;
                    font-weight: bold;
                    box-shadow: 0 2px 2px rgba(0,0,0,0.3);
                `;
                fullscreenButton.addEventListener('click', function (e) {
                    e.preventDefault();
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen()
                            .then(() => fullscreenButton.innerText = 'Exit Fullscreen')
                            .catch(console.error);
                    } else {
                        document.exitFullscreen()
                            .then(() => fullscreenButton.innerText = 'Fullscreen')
                            .catch(console.error);
                    }
                });
                document.body.appendChild(fullscreenButton);
            };
            document.body.appendChild(script);
        };
		
// end translator


    </script>
	
<!-- Netplay shim: robust netplayInject helper and DataChannel wrapping -->
<script>
(function(){
  if (window.__netplay_shim_installed) return;
  window.__netplay_shim_installed = true;
  window.__NETPLAY_SHIM_VERBOSE = !!window.__NETPLAY_SHIM_VERBOSE;
  console.log('[netplay-shim] installing netplayInject shim');

  // simple queue (keeps [playerIndex, keyOrButton, pressed, ts])
  window.__netplay_inject_queue = window.__netplay_inject_queue || [];

  function netplayInject(playerIndex, keyOrButton, pressed) {
    try {
      const isNumeric = (typeof keyOrButton === 'number' && isFinite(keyOrButton));
      // batch object: { events: [...] }
      const isBatch = (keyOrButton && typeof keyOrButton === 'object' && Array.isArray(keyOrButton.events));

      if (isBatch) {
        // Prefer emulator batch handler
        if (typeof window.EJS_handleRemoteInputs === 'function') {
          if (window.__NETPLAY_SHIM_VERBOSE) console.log('[netplay-shim] calling EJS_handleRemoteInputs (batch)');
          try { window.EJS_handleRemoteInputs(keyOrButton); return true; } catch(e) {}
        }
        // else, expand into individual events and call recursively (they will queue if needed)
        for (const ev of keyOrButton.events) {
          try { netplayInject(ev.player, (typeof ev.buttonIndex === 'number' ? Number(ev.buttonIndex) : ev.key || ev), (typeof ev.value === 'number' ? ev.value : (ev.type && String(ev.type).toLowerCase().includes('down') ? 1 : 0))); } catch(e){}
        }
        return false;
      }

      // numeric fast-path: EJS_simulateInput -> EJS_emulator.gameManager.simulateInput
      if (isNumeric) {
        if (typeof window.EJS_simulateInput === 'function') {
          if (window.__NETPLAY_SHIM_VERBOSE) console.log('[netplay-shim] EJS_simulateInput fast-path', playerIndex, keyOrButton, pressed);
          try { window.EJS_simulateInput(playerIndex, keyOrButton, pressed); return true; } catch(e) {}
        }
        if (window.EJS_emulator && window.EJS_emulator.gameManager && typeof window.EJS_emulator.gameManager.simulateInput === 'function') {
          if (window.__NETPLAY_SHIM_VERBOSE) console.log('[netplay-shim] direct gameManager.simulateInput', playerIndex, keyOrButton, pressed);
          try { window.EJS_emulator.gameManager.simulateInput(playerIndex, keyOrButton, pressed); return true; } catch(e) {}
        }
      }

      // If we get here, queue the event until emulator offers an API.
      window.__netplay_inject_queue.push([playerIndex, keyOrButton, pressed, Date.now()]);
      if (window.__NETPLAY_SHIM_VERBOSE) console.log('[netplay-shim] queued inject', playerIndex, keyOrButton, pressed, 'queueLen', window.__netplay_inject_queue.length);
      return false;
    } catch (err) {
      console.warn('[netplay-shim] netplayInject exception', err);
      return false;
    }
  }

  // flush queued events when emulator API becomes available
  function _netplay_inject_flush_once() {
    try {
      if (!window.__netplay_inject_queue || window.__netplay_inject_queue.length === 0) return;
      if (!(typeof window.EJS_handleRemoteInputs === 'function' || typeof window.EJS_simulateInput === 'function' || (window.EJS_emulator && window.EJS_emulator.gameManager && typeof window.EJS_emulator.gameManager.simulateInput === 'function'))) return;
      while (window.__netplay_inject_queue.length) {
        const it = window.__netplay_inject_queue.shift();
        const [playerIndex, keyOrButton, pressed] = it;
        if (keyOrButton && typeof keyOrButton === 'object' && Array.isArray(keyOrButton.events)) {
          try { if (typeof window.EJS_handleRemoteInputs === 'function') { window.EJS_handleRemoteInputs(keyOrButton); continue; } } catch(e){}
        }
        try { netplayInject(playerIndex, keyOrButton, pressed); } catch(e){}
      }
      if (window.__NETPLAY_SHIM_VERBOSE) console.log('[netplay-shim] flushed queued inject events');
    } catch(e) {
      console.warn('[netplay-shim] flush error', e);
    }
  }

  // poll for availability, but stop after queue empties (low overhead)
  const __netplay_flush_interval = setInterval(function(){
    try { _netplay_inject_flush_once(); if (!window.__netplay_inject_queue.length) clearInterval(__netplay_flush_interval); } catch(e){}
  }, 150);

  // expose helper globally for compatibility
  window.netplayInject = netplayInject;

  // Wrap DataChannel-like objects to insert logging and resilience (non-invasive)
  function wrapDc(dc) {
    if (!dc || dc.__netplay_shim_wrapped) return;
    const orig = dc.onmessage;
    const lastSeqForSlot = {};
    dc.onmessage = function(ev) {
// robustly resolve incomingPlayer & sequence: accept numeric or numeric-string player and track lastSeq
try {
  const e = (arguments && arguments[0]) ? arguments[0] : null;
  let msgObj = e;
  if (typeof msgObj === 'string') {
    try { msgObj = JSON.parse(msgObj); } catch (err) { /* keep string */ }
  }
  const incomingPlayer = (msgObj && (typeof msgObj.player === 'number' || (typeof msgObj.player === 'string' && /^\d+$/.test(msgObj.player))))
    ? Number(msgObj.player)
    : (typeof dc._assignedSlot === 'number' ? dc._assignedSlot : null);
  if (incomingPlayer === null) {
    // cannot resolve player, continue to original handler logic
  } else {
    const evSeq = (msgObj && (typeof msgObj.seq === 'number')) ? msgObj.seq : null;
    if (evSeq !== null) {
      const last = lastSeqForSlot[incomingPlayer] || 0;
      if (evSeq <= last) {
        // stale packet - ignore early
        return;
      }
      lastSeqForSlot[incomingPlayer] = evSeq;
    }
    if (msgObj && typeof msgObj.player === 'undefined') msgObj.player = incomingPlayer;
    if (arguments && arguments.length) arguments[0] = msgObj;
  }
} catch (err) {
  // non-fatal, fall back to original behavior
}

      try {
        // preserve prior behavior where possible
        if (typeof orig === 'function') {
          try { orig.call(dc, ev); } catch(e) { if (window.__NETPLAY_SHIM_VERBOSE) console.warn('[netplay-shim] orig dc.onmessage failed', e); }
        }
        // Our shim will not attempt to reparse or duplicate logic if the host page already fully handles inputs.
      } catch(e) {
        if (window.__NETPLAY_SHIM_VERBOSE) console.warn('[netplay-shim] wrapped dc.onmessage error', e);
      }
    };
    dc.__netplay_shim_wrapped = true;
    if (window.__NETPLAY_SHIM_VERBOSE) console.log('[netplay-shim] wrapped dc.onmessage', dc);
  }

  // Periodically wrap known DataChannel objects (npw.dc etc.)
  const checker = setInterval(function(){
    try {
      if (window.npw && window.npw.dc) wrapDc(window.npw.dc);
      if (window.netplay && window.netplay.dc) wrapDc(window.netplay.dc);
      // find any candidate DC-like objects on window (lightweight)
      for (const k of ['dc','peerConnection','dataChannel']) {
        if (window[k] && window[k].onmessage && !window[k].__netplay_shim_wrapped) wrapDc(window[k]);
      }
    } catch(e){}
  }, 500);

  if (window.__NETPLAY_SHIM_VERBOSE) console.log('[netplay-shim] installed netplayInject helper. Use window.netplayInject(playerIndex, keyOrButton, pressed) to inject input.');
})();
</script>


</body>
</html>